{% import "views/_helper.njk" as docs %}
{% import "views/_data.njk" as data %}
{% macro regex(useSingleQuotes = false) -%}
^((?!ticket).)*&dollar;{% if useSingleQuotes == true %}&apos;{% else %}&quot;{% endif %}
{%- endmacro %}

# 数据存储开发指南 · {{platform_name}}

数据存储（LeanStorage）是 LeanCloud 提供的核心功能之一，可用于存放和查询应用数据。下面的代码展示了如何创建一个对象并将其存入云端：

{% if platform_name === "Objective-C" %}
```objc
// 构建对象
AVObject *todo = [AVObject objectWithClassName:@"Todo"];

// 为属性赋值
[todo setObject:@"工程师周会"        forKey:@"title"];
[todo setObject:@"周二两点，全体成员" forKey:@"content"];

// 将对象保存到云端
[todo saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // 成功保存之后，执行其他逻辑
        NSLog(@"保存成功。objectId：%@", todo.objectId);
    } else {
        // 异常处理
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 声明 class
var Todo = AV.Object.extend('Todo');

// 构建对象
var todo = new Todo();

// 为属性赋值
todo.set('title',   '工程师周会');
todo.set('content', '周二两点，全体成员');

// 将对象保存到云端
todo.save().then(function (todo) {
  // 成功保存之后，执行其他逻辑
  console.log('保存成功。objectId：' + todo.id);
}, function (error) {
  // 异常处理
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 声明 class
Todo = leancloud.Object.extend('Todo')

# 构建对象
todo = Todo()

# 为属性赋值
todo.set('title',   '工程师周会')
todo.set('content', '周二两点，全体成员')

# 将对象保存到云端
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 构建对象
$todo = new LeanObject("Todo");

// 为属性赋值
$todo->set("title",   "工程师周会");
$todo->set("content", "周二两点，全体成员");

// 将对象保存到云端
$todo->save();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 构建对象
AVObject todo = new AVObject("Todo");

// 为属性赋值
todo.put("title",   "工程师周会");
todo.put("content", "周二两点，全体成员");

// 将对象保存到云端
todo.saveInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // 成功保存之后，执行其他逻辑
        System.out.println("保存成功。objectId：" + todo.getObjectId());
    }
    public void onError(Throwable throwable) {
        // 异常处理
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    // 构建对象
    let todo = LCObject(className: "Todo")

    // 为属性赋值
    try todo.set("title",   value: "工程师周会")
    try todo.set("content", value: "周二两点，全体成员")

    // 将对象保存到云端
    _ = todo.save { result in
        switch result {
        case .success:
            // 成功保存之后，执行其他逻辑
            break
        case .failure(error: let error):
            // 异常处理
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}

{% call docs.noteWrap() %}
我们为各个平台或者语言开发的 SDK 在底层都是通过 HTTPS 协议调用统一的 [REST API](rest_api.html)，提供完整的接口对数据进行各类操作。
{% endcall %}

## SDK 安装与初始化

{% if platform_name === "Objective-C" %}
请阅读 [Objective-C 安装指南](sdk_setup-objc.html)。
{% endif %}
{% if platform_name === "JavaScript" %}
请阅读 [JavaScript 安装指南](sdk_setup-js.html)。
{% endif %}
{% if platform_name === "Python" %}
请阅读 [Python 安装指南](sdk_setup-python.html)。
{% endif %}
{% if platform_name === "PHP" %}
请阅读 [PHP 安装指南](sdk_setup-php.html)。
{% endif %}
{% if platform_name === "Android / Java" %}
请阅读 [Android / Java 安装指南](sdk_setup-java.html)。
{% endif %}
{% if platform_name === "Swift" %}
请阅读 [Swift 安装指南](sdk_setup-swift.html)。
{% endif %}

{% if platform_name === "Android / Java" %}

## Android SDK 老版本迁移

如果你已经在使用我们 [老版本 Android SDK](https://github.com/leancloud/android-sdk-all)，要迁移到当前新版本，函数接口方面新版 SDK 尽可能沿用老版 SDK 的命名方式，所以要做的改动主要是Callback 回调机制的修改。

### Observable 接口
例如老的方式保存一个 AVObject 的代码如下(Callback 方式)：
```java
final AVObject todo = new AVObject("Todo");
todo.put("title", "工程师周会");
todo.put("content", "每周工程师会议，周一下午2点");
todo.put("location", "会议室");// 只要添加这一行代码，服务端就会自动添加这个字段
todo.saveInBackground(new SaveCallback() {
  @Override
  public void done(AVException e) {
    if (e == null) {
      // 存储成功
      Log.d(TAG, todo.getObjectId());// 保存成功之后，objectId 会自动从服务端加载到本地
    } else {
      // 失败的话，请检查网络环境以及 SDK 配置是否正确
    }
  }
});
```
而新版本 SDK 里 `AVObject#saveInBackground` 方法，返回的是一个 `Observable<? extends AVObject>` 实例，我们需要 subscribe 才能得到结果通知，新版本的实现方式如下：
```java
final AVObject todo = new AVObject("Todo");
todo.put("title", "工程师周会");
todo.put("content", "每周工程师会议，周一下午2点");
todo.put("location", "会议室");// 只要添加这一行代码，服务端就会自动添加这个字段
todo.saveInBackground().subscribe(new Observer<AVObject>() {
  public void onSubscribe(Disposable disposable) {
  }
  public void onNext(AVObject avObject) {
    System.out.println("remove field finished.");
  }
  public void onError(Throwable throwable) {
  }
  public void onComplete() {
  }
});
```

### ObserverBuilder 工具类
这个改动比较大，考虑到尽量降低迁移成本，我们准备了一个工具类 `cn.leancloud.convertor.ObserverBuilder`，该类有一系列的 `buildSingleObserver` 方法，来帮我们由原来的 Callback 回调函数生成 `Observable` 实例，上面的例子按照这种方法可以变为：

```java
final AVObject todo = new AVObject("Todo");
todo.put("title", "工程师周会");
todo.put("content", "每周工程师会议，周一下午2点");
todo.put("location", "会议室");// 只要添加这一行代码，服务端就会自动添加这个字段
todo.saveInBackground().subscribe(ObserverBuilder.buildSingleObserver(new SaveCallback() {
  @Override
  public void done(AVException e) {
    if (e == null) {
      // 存储成功
      Log.d(TAG, todo.getObjectId());// 保存成功之后，objectId 会自动从服务端加载到本地
    } else {
      // 失败的话，请检查网络环境以及 SDK 配置是否正确
    }
  }
}));
```
处理异步调用结果的两种方式，可供大家自由选择。

** 另外，在新版 SDK 中我们统一将包名的 root 目录由 `com.avos.avoscloud` 改成了 `cn.leancloud`，也需要大家做一个全局替换。** 

{% endif %}

{% if platform_name === "JavaScript" %}
## Web 安全

如果在前端使用 JavaScript SDK，当你准备正式发布的时候，请务必在 [控制台 > 设置 > 安全中心](/dashboard/app.html?appid={{appid}}#/security) 中配置 **Web 安全域名**，这样可以防止其他人通过外网其他地址盗用你的服务器资源。

不过这样做还不够，因为你的应用是暴露在公网上的，任何人都有可能伪造请求来绕过前面的防范措施。所以 LeanCloud 还提供了其他方法来保护你的应用安全。参见：

- [数据和安全](data_security.html)
- [ACL 权限管理开发指南](acl-guide.html)
{% endif %}

## 对象

### `{{ baseObjectName }}`

`{{ baseObjectName }}` 是 LeanCloud 对复杂对象的封装，每个 `{{ baseObjectName }}` 包含若干与 JSON 格式兼容的属性值对（也称键值对，key-value pairs）。这个数据是无模式化的（schema free），意味着你不需要提前标注每个 `{{ baseObjectName }}` 上有哪些 key，你只需要随意设置键值对就可以，云端会保存它。

比如说，一个保存着单个 Todo 的 `{{ baseObjectName }}` 可能包含如下数据：

```json
title:      "给小林发邮件确认会议时间",
isComplete: false,
priority:   2,
tags:       ["工作", "销售"]
```

{# Keys must be alphanumeric strings. Values can be strings, numbers, booleans, or even arrays, objects, and anything that can be JSON-encoded. #}

### 数据类型

`{{ baseObjectName }}` 支持的数据类型包括 `String`、`Number`、`Boolean`、`Object`、`Array`、`Date`、`null` 等等。你可以通过嵌套的方式在 `Object` 或 `Array` 里面存储更加结构化的数据。

`{{ baseObjectName }}` 还支持两种特殊的数据类型 `Pointer` 和 `File`，可以分别用来存储指向其他 `{{ baseObjectName }}` 的指针以及二进制数据。

`{{ baseObjectName }}` 同时支持 `GeoPoint`，可以用来存储地理位置信息。参见 [GeoPoint](#geopoint)。

以下是一些示例：

{% if platform_name === "Objective-C" %}
```objc
// 基本类型
NSNumber     *boolean    = @(YES);
NSNumber     *number     = [NSNumber numberWithInt:2018];
NSString     *string     = [NSString stringWithFormat:@"%@ 流行音乐榜单", number];
NSDate       *date       = [NSDate date];
NSData       *data       = [@"Hello world!" dataUsingEncoding:NSUTF8StringEncoding];
NSArray      *array      = [NSArray arrayWithObjects: string, number, nil];
NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys: number, @"number", string, @"string", nil];

// 构建对象
AVObject *testObject = [AVObject objectWithClassName:@"TestObject"];
[testObject setObject:boolean    forKey:@"testBoolean"];
[testObject setObject:number     forKey:@"testInteger"];
[testObject setObject:string     forKey:@"testString"];
[testObject setObject:date       forKey:@"testDate"];
[testObject setObject:data       forKey:@"testData"];
[testObject setObject:array      forKey:@"testArray"];
[testObject setObject:dictionary forKey:@"testDictionary"];
[testObject saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 声明 class
var TestObject = AV.Object.extend('TestObject');

// 基本类型
var number = 2018;
var string = number + ' 流行音乐榜单';
var date   = new Date();
var array  = [string, number];
var object = {
  number: number,
  string: string
};

// 指向另一个 class 的 AV.Object
var pointer = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');

// 构建对象
var testObject = new TestObject();
testObject.set('testNumber',  number);
testObject.set('testString',  string);
testObject.set('testDate',    date);
testObject.set('testArray',   array);
testObject.set('testObject',  object);
testObject.set('testNull',    null);
testObject.set('testPointer', pointer);
testObject.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

# 声明 class
TestObject = leancloud.Object.extend('TestObject')

# 构建对象
test_object = TestObject()
test_object.set('testString',  '工作')
test_object.set('testInt',     108)
test_object.set('testFloat',   1.890)
test_object.set('testBoolean', True)
test_object.set('testList',    [1, 2, [3, 4, 'string']])
test_object.set('testDict',    {'item1': 12, 'item2': 'string', 'item3': [1, 2, '3']})
test_object.set('testDate',    datetime.now())
test_object.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 基本类型
$bool       = true;
$number     = 2018;
$string     = $number . " 流行音乐榜单";
$date       = new \DateTime();
$bytesArray = Bytes::createFromBase64Data(base64_encode("Hello world!"));

// 构建对象
$testObject = new LeanObject("TestObject");
$testObject->set("testBoolean", $bool);
$testObject->set("testInteger", $number);
$testObject->set("testString",  $string);
$testObject->set("testData",    $bytesArray);
$testObject->set("testDate",    $date);
$testObject->set("testArray",   array($string, $number));
$testObject->set("testAssociativeArray",
                 array("number" => $number,
                       "string" => $string));
$testObject->save();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 基本类型
boolean bool = true;
int number = 2018;
String string = number + " 流行音乐榜单";
Date date = new Date();
byte[] data = "Hello world!".getBytes();
ArrayList<Object> arrayList = new ArrayList<>();
arrayList.add(number);
arrayList.add(string);
HashMap<Object, Object> hashMap = new HashMap<>();
hashMap.put("number", number);
hashMap.put("string", string);

// 构建对象
AVObject testObject = new AVObject("TestObject");
testObject.put("testBoolean",   bool);
testObject.put("testInteger",   number);
testObject.put("testDate",      date);
testObject.put("testData",      data);
testObject.put("testArrayList", arrayList);
testObject.put("testHashMap",   hashMap);
testObject.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let number       : LCNumber       = 42
let bool         : LCBool         = true
let string       : LCString       = "foo"
let dictionary   : LCDictionary   = LCDictionary(["name": string, "count": number])
let array        : LCArray        = LCArray([number, bool, string])
let data         : LCData         = LCData()
let date         : LCDate         = LCDate()
let null         : LCNull         = LCNull()
let geoPoint     : LCGeoPoint     = LCGeoPoint(latitude: 45, longitude: -45)
let acl          : LCACL          = LCACL()
let object       : LCObject       = LCObject()
let relation     : LCRelation     = object.relationForKey("elements")
let user         : LCUser         = LCUser()
let file         : LCFile         = LCFile()
let installation : LCInstallation = LCInstallation()
```
{% endif %}

我们不推荐{% if platform_name === "Objective-C" %}通过 `NSData` {% endif %}{% if platform_name === "JavaScript" %}{% endif %}{% if platform_name === "Python" %}通过 `byte[]` {% endif %}{% if platform_name === "PHP" %}通过 `Bytes` {% endif %}{% if platform_name === "Android / Java" %}通过 `byte[]` {% endif %}{% if platform_name === "Swift" %}通过 `LCData` {% endif %}在 `{{ baseObjectName }}` 里面存储图片、文档等大型二进制数据。每个 `{{ baseObjectName }}` 的大小不应超过 **128 KB**。如需存储大型文件，可创建 `{{ fileObjectName }}` 实例并将将其关联到 `{{ baseObjectName }}` 的某个属性上。参见 [文件](#文件)。

{% call docs.noteWrap() %}
注意：时间类型在云端将会以 UTC 时间格式存储，但是客户端在读取之后会转化成本地时间。

[控制台 > 存储 > 数据](/dashboard/data.html?appid={{appid}}#/) 中展示的日期数据也会依据操作系统的时区进行转换。一个例外是当你通过 [REST API](rest_api.html) 获得数据时，这些数据将以 UTC 呈现。你可以手动对它们进行转换。
{% endcall %}

若想了解 LeanCloud 是如何保护应用数据的，请阅读 [数据和安全](data_security.html)。

### 构建对象

下面的代码构建了一个 class 为 `Todo` 的 `{{ baseObjectName }}`：

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo"];

// 等同于
AVObject *todo = [[AVObject alloc] initWithClassName:@"Todo"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 为 AV.Object 创建子类
var Todo = AV.Object.extend('Todo');

// 为该类创建一个新实例
var todo = new Todo();

// 你还可以直接使用 AV.Object 的构造器
new AV.Object('Todo');
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 为 leancloud.Object 创建子类
Todo = leancloud.Object.extend('Todo')

# 为该类创建一个新实例
todo = Todo()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = new LeanObject("Todo");

// 等同于
$todo = LeanObject::create("Todo");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject todo = new AVObject("Todo");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo")
```
{% endif %}

在构建对象时，为了使云端知道对象属于哪个 class，需要将 class 的名字作为参数传入。你可以将 LeanCloud 里面的 class 比作关系型数据库里面的表。一个 class 的名字必须以字母开头，且只能包含数字、字母和下划线。

{% if platform_name === "JavaScript" %}
{% call docs.noteWrap() %}
如果你的应用时不时出现 `Maximum call stack size exceeded` 异常，可能是因为在循环或回调中调用了 `AV.Object.extend`。有两种方法可以避免这种异常：一种是在循环或回调外声明 class，确保不会对一个 class 执行多次 `AV.Object.extend`；另一种是将 SDK 更换到 1.4 或更高版本。
{% endcall %}

如果你使用的是 ES6，还可以通过 `extends` 关键字来创建 `AV.Object` 的子类，然而 SDK 无法自动识别你创建的子类。你需要通过这种方式手动注册一下：

```js
class Todo extends AV.Object {
  // 自定义属性和方法
}

// 注册子类
AV.Object.register(Todo);
```

这样你就能在 `AV.Object` 的子类中添加额外的方法和属性了。
{% endif %}

### 保存对象

下面的代码将一个 class 为 `Todo` 的对象存入云端：

{% if platform_name === "Objective-C" %}
```objc
// 构建对象
AVObject *todo = [AVObject objectWithClassName:@"Todo"];

// 为属性赋值
[todo setObject:@"马拉松报名" forKey:@"title"];
[todo setObject:@2 forKey:@"priority"];

// 将对象保存到云端
[todo saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // 成功保存之后，执行其他逻辑
        NSLog(@"保存成功。objectId：%@", todo.objectId);
    } else {
        // 异常处理
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 声明 class
var Todo = AV.Object.extend('Todo');

// 构建对象
var todo = new Todo();

// 为属性赋值
todo.set('title', '马拉松报名');
todo.set('priority', 2);

// 将对象保存到云端
todo.save().then(function (todo) {
  // 成功保存之后，执行其他逻辑
  console.log('保存成功。objectId：' + todo.id);
}, function (error) {
  // 异常处理
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 声明 class
Todo = leancloud.Object.extend('Todo')

# 构建对象
todo = Todo()

# 为属性赋值
todo.set('title', '马拉松报名')
todo.set('priority', 2)

# 将对象保存到云端
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 构建对象
$todo = new LeanObject("Todo");

// 为属性赋值
$todo->set("title", "马拉松报名");
$todo->set("priority", 2);

// 将对象保存到云端
$todo->save();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 构建对象
AVObject todo = new AVObject("Todo");

// 为属性赋值
todo.put("title", "马拉松报名");
todo.put("priority", 2);

// 将对象保存到云端
todo.saveInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // 成功保存之后，执行其他逻辑
        System.out.println("保存成功。objectId：" + todo.getObjectId());
    }
    public void onError(Throwable throwable) {
        // 异常处理
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    // 构建对象
    let todo = LCObject(className: "Todo")

    // 为属性赋值
    try todo.set("title", value: "马拉松报名")
    try todo.set("priority", value: 2)

    // 将对象保存到云端
    _ = todo.save { result in
        switch result {
        case .success:
            // 成功保存之后，执行其他逻辑
            break
        case .failure(error: let error):
            // 异常处理
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}

为了确认对象已经保存成功，我们可以到 [控制台 > 存储 > 数据 > `Todo`](/dashboard/data.html?appid={{appid}}#/Todo) 里面看一下，应该会有一行新的数据产生。点一下这个数据的 `objectId`，应该能看到类似这样的内容：

```json
{
  "title":     "马拉松报名",
  "priority":  2,
  "ACL": {
    "*": {
      "read":  true,
      "write": true
    }
  },
  "objectId":  "582570f38ac247004f39c24b",
  "createdAt": "2017-11-11T07:19:15.549Z",
  "updatedAt": "2017-11-11T07:19:15.549Z"
}
```

{% call docs.noteWrap() %}
无需在 [控制台 > 存储 > 数据](/dashboard/data.html?appid={{appid}}#/) 里面创建新的 `Todo` class 即可运行前面的代码。如果 class 不存在，它将自动创建。
{% endcall %}

以下是一些对象的内置属性，会在对象保存时自动创建，无需手动指定：

内置属性 | 类型 | 描述
--- | --- | ---
`objectId` | `{% if platform_name === "Objective-C" %}NSString{% endif %}{% if platform_name === "JavaScript" %}String{% endif %}{% if platform_name === "Python" %}str{% endif %}{% if platform_name === "PHP" %}String{% endif %}{% if platform_name === "Android / Java" %}String{% endif %}{% if platform_name === "Swift" %}LCString{% endif %}` | 该对象唯一的 ID 标识。
`ACL` | `{% if platform_name === "Objective-C" %}AVACL{% endif %}{% if platform_name === "JavaScript" %}AV.ACL{% endif %}{% if platform_name === "Python" %}leancloud.ACL{% endif %}{% if platform_name === "PHP" %}ACL{% endif %}{% if platform_name === "Android / Java" %}AVACL{% endif %}{% if platform_name === "Swift" %}LCACL{% endif %}` | 该对象的权限控制，实际上是一个 JSON 对象，控制台做了展现优化。
`createdAt` | `{% if platform_name === "Objective-C" %}NSDate{% endif %}{% if platform_name === "JavaScript" %}Date{% endif %}{% if platform_name === "Python" %}datetime.datetime{% endif %}{% if platform_name === "PHP" %}DateTime{% endif %}{% if platform_name === "Android / Java" %}Date{% endif %}{% if platform_name === "Swift" %}LCDate{% endif %}` | 该对象被创建的时间。
`updatedAt` | `{% if platform_name === "Objective-C" %}NSDate{% endif %}{% if platform_name === "JavaScript" %}Date{% endif %}{% if platform_name === "Python" %}datetime.datetime{% endif %}{% if platform_name === "PHP" %}DateTime{% endif %}{% if platform_name === "Android / Java" %}Date{% endif %}{% if platform_name === "Swift" %}LCDate{% endif %}` | 该对象最后一次被修改的时间。

这些属性的值会在对象被存入云端时自动填入，代码中尚未保存的 `{{ baseObjectName }}` 不存在这些属性。

属性名（**keys**）只能包含字母、数字和下划线。自定义属性不得以双下划线（`__`）开头或与任何系统保留字段和内置属性（`ACL`、`className`、`createdAt`、`objectId` 和 `updatedAt`）重名，无论大小写。

属性值（**values**）可以是字符串、数字、布尔值、数组或字典（任何能以 JSON 编码的数据）。参见 [数据类型](#数据类型)。

我们推荐使用驼峰式命名法（CamelCase）为类和属性来取名。类，采用大驼峰法，如 `CustomData`。属性，采用小驼峰法，如 `imageUrl`。

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Android / Java" or platform_name === "Swift" %}
### 获取对象

对于已经保存到云端的 `{{ baseObjectName }}`，可以通过它的 `objectId` 将其取回：
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query getObjectInBackgroundWithId:@"582570f38ac247004f39c24b" block:^(AVObject *todo, NSError *error) {
    // todo 就是 objectId 为 582570f38ac247004f39c24b 的 Todo 实例
    NSString *title    = todo[@"title"];
    int priority       = [[todo objectForKey:@"priority"] intValue];

    // 获取内置属性
    NSString *objectId = todo.objectId;
    NSDate *updatedAt  = todo.updatedAt;
    NSDate *createdAt  = todo.createdAt;
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.get('582570f38ac247004f39c24b').then(function (todo) {
  // todo 就是 objectId 为 582570f38ac247004f39c24b 的 Todo 实例
  var title     = todo.get('title');
  var priority  = todo.get('priority');

  // 获取内置属性
  var objectId  = todo.id;
  var updatedAt = todo.updatedAt;
  var createdAt = todo.createdAt;
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
todo = query.get('582570f38ac247004f39c24b')

# todo 就是 objectId 为 582570f38ac247004f39c24b 的 Todo 实例
title      = todo.get('title')
priority   = todo.get('priority')

# 获取内置属性
object_id  = todo.id
update_at  = todo.updated_at
created_at = todo.created_at
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.getInBackground("582570f38ac247004f39c24b").subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // todo 就是 objectId 为 582570f38ac247004f39c24b 的 Todo 实例
        String title    = todo.getString("title");
        int priority    = todo.getInt("priority");

        // 获取内置属性
        String objectId = todo.getObjectId();
        Date updatedAt  = todo.getUpdatedAt();
        Date createdAt  = todo.getCreatedAt();
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
let _ = query.get("582570f38ac247004f39c24b") { (result) in
    switch result {
    case .success(object: let todo):
        // todo 就是 objectId 为 582570f38ac247004f39c24b 的 Todo 实例
        let title     = todo.get("title")
        let priority  = todo.get("priority")

        // 获取内置属性
        let objectId  = todo.objectId
        let updatedAt = todo.updatedAt
        let createdAt = todo.createdAt
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Swift" %}
对象拿到之后，可以通过 `get` 方法来获取各个属性的值。注意 `objectId`、`updatedAt`和`createdAt` 这三个内置属性不能通过 `get` 获取或通过 `set` 修改，只能由云端自动进行填充。尚未保存的 `{{ baseObjectName }}` 不存在这些属性。
{% endif %}

如果你试图获取一个不存在的属性，SDK 不会报错，而是会返回 `{% if platform_name === "Objective-C" %}nil{% endif %}{% if platform_name === "JavaScript" %}undefined{% endif %}{% if platform_name === "Python" %}None{% endif %}{% if platform_name === "Android / Java" %}null{% endif %}{% if platform_name === "Swift" %}nil{% endif %}`。

{% if platform_name === "JavaScript" %}
如果需要一次性获取返回对象的所有属性（比如进行数据绑定）而非显式地调用 `get`，可以利用 `AV.Object` 实例的 `toJSON` 方法：

```js
var query = new AV.Query('Todo');
query.get('582570f38ac247004f39c24b').then(function (todo) {
  console.log(todo.toJSON());
  // {
  //   createdAt: "2017-03-08T11:25:07.804Z",
  //   objectId: "582570f38ac247004f39c24b",
  //   priority: 2,
  //   title: "工程师周会",
  //   updatedAt: "2017-03-08T11:25:07.804Z"
  // }
});
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Android / Java" or platform_name === "Swift" %}
#### 同步对象

当云端数据发生更改时，你可以调用 `{% if platform_name === "Objective-C" %}fetchInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Python" %}fetch{% endif %}{% if platform_name === "Android / Java" %}fetchInBackground{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}` 方法来刷新对象，使之与云端数据同步：
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"582570f38ac247004f39c24b"];
[todo fetchInBackgroundWithBlock:^(AVObject *todo, NSError *error) {
    // todo 已刷新
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.fetch().then(function (todo) {
  // todo 已刷新
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo.create_without_data('582570f38ac247004f39c24b')
todo.fetch()
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "582570f38ac247004f39c24b");
todo.fetchInBackground().subscribe(new Observable<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // todo 已刷新
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
_ = todo.fetch { result in
    switch result {
    case .success:
        // todo 已刷新
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" or platform_name === "Swift" %}
刷新操作会强行使用云端的属性值覆盖本地的属性。因此如果本地有属性修改，**`{% if platform_name === "Objective-C" %}fetchInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Android / Java" %}fetchInBackground{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}` 操作会丢弃这些修改**。为避免这种情况，你可以在刷新时指定 **需要刷新的属性**，这样只有指定的属性会被刷新（包括内置属性 `objectId`、`createdAt` 和 `updatedAt`），其他属性不受影响。
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"582570f38ac247004f39c24b"];
NSArray *keys = [NSArray arrayWithObjects:@"priority", @"location", nil];
[todo fetchInBackgroundWithKeys:keys block:^(AVObject *todo, NSError *error) {
    // 只有 priority 和 location 会被获取和刷新
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.fetch({
  keys: 'priority, location'
}).then(function (todo) {
  // 只有 priority 和 location 会被获取和刷新
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "582570f38ac247004f39c24b");
String keys = "priority, location";
todo.fetchInBackground(keys).subscribe(new Observable<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        // 只有 priority 和 location 会被获取和刷新
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
todo.fetch(keys: ["priority", "location"]) { (result) in
    switch result {
    case .success:
        // 只有 priority 和 location 会被获取和刷新
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{# After the object is refreshed successfully, its `updatedAt` value will be updated on the client. The cloud won't have this new value until the next save or fetch happens, thus some network bandwidth can be saved out of it. #}

{# With that in mind, let's make it more fun. Let's build a new `AV.Object` locally from scratch with an objectId, and retrieve more field values associated with this object from the cloud without using `AV.Query`. #}

### 更新对象

要更新一个对象，只需指定需要更新的属性名和属性值，然后调用 `{% if platform_name === "Objective-C" %}saveInBackground{% endif %}{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Python" %}save{% endif %}{% if platform_name === "PHP" %}save{% endif %}{% if platform_name === "Android / Java" %}saveInBackground{% endif %}{% if platform_name === "Swift" %}save{% endif %}` 方法。例如：

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"582570f38ac247004f39c24b"];
[todo setObject:@"这周周会改到周三下午三点。" forKey:@"content"];
[todo saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.set('content', '这周周会改到周三下午三点。');
todo.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo.create_without_data('582570f38ac247004f39c24b')
todo.set('content', '这周周会改到周三下午三点。')
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = LeanObject::create("Todo", "582570f38ac247004f39c24b");
$todo->set("content", '这周周会改到周三下午三点。');
$todo->save();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "582570f38ac247004f39c24b");
todo.put("content", "这周周会改到周三下午三点。");
todo.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
todo.set("content", value: "这周周会改到周三下午三点。")
todo.save()
```
{% endif %}

LeanCloud 会自动识别需要更新的属性并将对应的数据发往云端，未更新的属性会保持原样。

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Android / Java" or platform_name === "Swift" %}
#### 按条件更新对象

通过传入 `query` 选项，可以按照指定条件去更新对象——当条件满足时，执行更新；条件不满足时，不执行更新并返回 `305` 错误。

例如，用户的账户表 `Account` 有一个余额字段 `balance`，同时有多个请求要修改该字段值。为避免余额出现负值，只有当金额小于或等于余额的时候才能接受请求：
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
AVObject *account = [AVObject objectWithClassName:@"Account" objectId:@"5745557f71cfe40068c6abe0"];
// 对 balance 原子减少 100
NSInteger amount = -100;
[account incrementKey:@"balance" byAmount:@(amount)];
// 设置条件
AVQuery *query = [[AVQuery alloc] init];
[query whereKey:@"balance" greaterThanOrEqualTo:@(-amount)];
AVSaveOption *option = [[AVSaveOption alloc] init];
option.query = query;
// 操作结束后，返回最新数据。
// 如果是新对象，则所有属性都会被返回，
// 否则只有更新的属性会被返回。
option.fetchWhenSave = YES;
[account saveInBackgroundWithOption:option block:^(BOOL succeeded, NSError * _Nullable error) {
    if (succeeded) {
        NSLog(@"当前余额为：%@", account[@"balance"]);
    } else if (error.code == 305) {
        NSLog(@"余额不足，操作失败！");
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var account = AV.Object.createWithoutData('Account', '5745557f71cfe40068c6abe0');
// 对 balance 原子减少 100
var amount = -100;
account.increment('balance', amount);
account.save(null, {
  // 设置条件
  query: new AV.Query('Account').greaterThanOrEqualTo('balance', -amount),
  // 操作结束后，返回最新数据。
  // 如果是新对象，则所有属性都会被返回，
  // 否则只有更新的属性会被返回。
  fetchWhenSave: true
}).then(function (account) {
  console.log('当前余额为：', account.get('balance'));
}, function (error) {
  if (error.code === 305) {
    console.error('余额不足，操作失败！');
  }
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Account = leancloud.Object.extend('Account')
account = Account.create_without_data('5745557f71cfe40068c6abe0')
# 对 balance 原子减少 100
amount = -100
account.increment('balance', amount)
# 设置条件
where = Account.query.greater_than_or_equal_to('balance', -amount)
# 操作结束后，返回最新数据。
# 如果是新对象，则所有属性都会被返回，
# 否则只有更新的属性会被返回。
account.fetch_when_save = True
try:
    account.save(where=where)
    print('当前余额为：', account.get('balance'))
except leancloud.LeanCloudError as e:
    if e.code == 305:
        print('余额不足，操作失败！')
    else:
        raise
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject account = AVObject.createWithoutData("Account", "5745557f71cfe40068c6abe0");
// 对 balance 原子减少 100
final int amount = -100;
account.increment("balance", amount);
// 设置条件
AVSaveOption option = new AVSaveOption();
option.query(new AVQuery<>("Account").whereGreaterThanOrEqualTo("balance", -amount));
// 操作结束后，返回最新数据。
// 如果是新对象，则所有属性都会被返回，
// 否则只有更新的属性会被返回。
option.setFetchWhenSave(true);
account.saveInBackground(option).subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject account) {
        System.out.println("当前余额为：" + account.get("balance"));
    }
    public void onError(Throwable throwable) {
        System.out.println("余额不足，操作失败！");
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    let account = LCObject(className: "Account", objectId: "5745557f71cfe40068c6abe0")
    // 对 balance 原子减少 100
    let amount = -100
    try account.increase("balance", by: amount)
    // 设置条件
    let query = LCQuery(className: "Account")
    query.whereKey("balance", .greaterThanOrEqualTo(-amount))
    let options: [LCObject.SaveOption] = [
        .query(query),
        // 操作结束后，返回最新数据。
        // 如果是新对象，则所有属性都会被返回，
        // 否则只有更新的属性会被返回。
        .fetchWhenSave
    ]
    account.save(options: options) { (result) in
        switch result {
        case .success:
            if let balance = account["balance"] {
                print("当前余额为：\(balance)")
            }
        case .failure(error: let error):
            if error.code == 305 {
                print("余额不足，操作失败！")
            }
        }
    }
} catch {
    print(error)
}
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Android / Java" or platform_name === "Swift" %}
**`query` 选项只对已存在的对象有效**，不适用于尚未存入云端的对象。

`query` 选项在有多个客户端需要更新同一属性的时候非常有用。相比于通过 `{{ baseQueryClassName }}` 查询 `{{ baseObjectName }}` 再对其进行更新的方法，这样做更加简洁，并且能够避免出现差错。
{% endif %}

#### 更新计数器

设想我们正在开发一个微博，需要统计一条微博有多少个赞和多少次转发。由于赞和转发的操作可能由多个客户端同时进行，直接在本地更新数字并保存到云端的做法极有可能导致差错。为保证计数的准确性，可以通过 **原子操作** 来增加或减少一个属性内保存的数字：

{% if platform_name === "Objective-C" %}
```objc
[post incrementKey:@"likes" byAmount:@1];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
post.increment('likes', 1);
```
{% endif %}
{% if platform_name === "Python" %}
```python
post.increment('likes', 1)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$post->increment("likes", 1);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
post.increment("likes", 1);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
try post.increase("likes", by: 1)
```
{% endif %}

可以指定需要增加或减少的值。若未指定，则默认使用 `1`。

#### 更新数组

更新数组也是原子操作。使用以下方法可以方便地维护数组类型的数据：

{% if platform_name === "Objective-C" %}
- `addObject:forKey:`<br/>将指定对象附加到数组末尾。
- `addObjectsFromArray:forKey:`<br/>将指定对象数组附加到数组末尾。
- `addUniqueObject:forKey:`<br/>将指定对象附加到数组末尾，确保对象唯一。
- `addUniqueObjectsFromArray:forKey:`<br/>将指定对象数组附加到数组末尾，确保对象唯一。
- `removeObject:forKey:`<br/>从数组字段中删除指定对象的所有实例。
- `removeObjectsInArray:forKey:`<br/>从数组字段中删除指定的对象数组。
{% endif %}
{% if platform_name === "JavaScript" %}
- `AV.Object.add('arrayKey', value)`<br/>将指定对象附加到数组末尾。
- `AV.Object.addUnique('arrayKey', value)`<br/>如果数组中不包含指定对象，则将该对象加入数组。对象的插入位置是随机的。
- `AV.Object.remove('arrayKey', value)`<br/>从数组字段中删除指定对象的所有实例。
{% endif %}
{% if platform_name === "Python" %}
- `add()`<br/>将指定对象附加到数组末尾。
- `add_unique()`<br/>如果数组中不包含指定对象，则将该对象加入数组。对象的插入位置是随机的。
- `remove()`<br/>从数组字段中删除指定对象的所有实例。
{% endif %}
{% if platform_name === "PHP" %}
- `addIn()`<br/>将指定对象附加到数组末尾。
- `addUniqueIn()`<br/>如果数组中不包含指定对象，则将该对象加入数组。对象的插入位置是随机的。
- `removeIn()`<br/>从数组字段中删除指定对象的所有实例。
{% endif %}
{% if platform_name === "Android / Java" %}
- `add()`<br/>将指定对象附加到数组末尾。
- `addUnique()`<br/>如果数组中不包含指定对象，则将该对象加入数组。对象的插入位置是随机的。
- `removeAll()`<br/>从数组字段中删除指定对象的所有实例。
{% endif %}
{% if platform_name === "Swift" %}
- `append(String, element: LCType)`<br/>将指定对象附加到数组末尾。
- `append(String, element: LCType, unique: Bool)`<br/>将指定对象附加到数组末尾，并且可以设置一个 `unique` 的 `bool` 值表示只是确保唯一，不会重复添加。
- `append(String, elements: [LCType])`<br/>将指定对象数组附加到数组末尾。
- `append(String, elements: [LCType], unique: Bool)`<br/>将指定对象数组附加到数组末尾，并且可以设置一个 `unique` 的 `bool` 值表示只是确保唯一，不会重复添加。
- `remove(String, element: LCType)`<br/>从数组字段中删除指定对象的所有实例。
- `remove(String, elements: [LCType])`<br/>从数组字段中删除指定的对象数组。
{% endif %}

例如，`Todo` 用一个 `alarms` 属性保存所有闹钟的时间。下面的代码将多个时间加入这个属性：

{% if platform_name === "Objective-C" %}
```objc
-(NSDate*) getDateWithDateString:(NSString*) dateString{
    NSDateFormatter *dateFormat = [[NSDateFormatter alloc] init];
    [dateFormat setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    NSDate *date = [dateFormat dateFromString:dateString];
    return date;
}

NSDate *alarm1 = [self getDateWithDateString:@"2018-04-30 07:10:00"];
NSDate *alarm2 = [self getDateWithDateString:@"2018-04-30 07:20:00"];
NSDate *alarm3 = [self getDateWithDateString:@"2018-04-30 07:30:00"];

NSArray *alarms = [NSArray arrayWithObjects:alarm1, alarm2, alarm3, nil];

AVObject *todo = [AVObject objectWithClassName:@"Todo"];
[todo addUniqueObjectsFromArray:alarms forKey:@"alarms"];
[todo saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var alarm1 = new Date('2018-04-30T07:10:00');
var alarm2 = new Date('2018-04-30T07:20:00');
var alarm3 = new Date('2018-04-30T07:30:00');

var alarms = [alarm1, alarm2, alarm3];

var todo = new AV.Object('Todo');
todo.addUnique('alarms', alarms);
todo.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

alarm1 = datetime(2018, 4, 30, 7, 10, 00)
alarm2 = datetime(2018, 4, 30, 7, 20, 00)
alarm3 = datetime(2018, 4, 30, 7, 30, 00)

Todo = leancloud.Object.extend('Todo')
todo = Todo()
todo.add_unique('alarms', alarm1)
todo.add_unique('alarms', alarm2)
todo.add_unique('alarms', alarm3)
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$alarm1 = new \DateTime("2018-04-30 07:10:00");
$alarm2 = new \DateTime("2018-04-30 07:20:00");
$alarm3 = new \DateTime("2018-04-30 07:30:00");

$todo = new LeanObject("Todo");
$todo->addUniqueIn("alarms", $alarm1);
$todo->addUniqueIn("alarms", $alarm2);
$todo->addUniqueIn("alarms", $alarm3);
$todo->save();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    Date date = dateFormat.parse(dateString);
    return date;
}

Date alarm1 = getDateWithDateString("2018-04-30 07:10:00");
Date alarm2 = getDateWithDateString("2018-04-30 07:20:00");
Date alarm3 = getDateWithDateString("2018-04-30 07:30:00");

AVObject todo = new AVObject("Todo");
todo.addAllUnique("alarms", Arrays.asList(alarm1, alarm2, alarm3));
todo.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
func dateWithString(_ string: String) -> LCDate {
    let dateFormatter = DateFormatter()

    dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
    dateFormatter.locale = Locale(identifier: "en_US_POSIX")

    let date = LCDate(dateFormatter.date(from: string)!)

    return date
}

func testSetArray() {
    do {
        let todo = LCObject(className: "Todo")

        let reminder1 = dateWithString("2018-04-30 07:10:00")
        let reminder2 = dateWithString("2018-04-30 07:20:00")

        try todo.set("reminders", value: [reminder1, reminder2])

        let result = todo.save()
        assert(result.isSuccess)

        let reminder3 = dateWithString("2018-04-30 07:30:00")

        try todo.append("reminders", element: reminder3, unique: true)

        _ = todo.save { result in
            switch result {
            case .success:
                break
            case .failure(error: let error):
                print(error)
            }
        }
    } catch {
        print(error)
    }
}
```
{% endif %}

{# Note that it is not currently possible to atomically add and remove items from an array in the same save. You will have to call `save` in between every different kind of array operation. #}

### 删除对象

下面的代码从云端删除一个 `Todo` 对象；

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo" objectId:@"582570f38ac247004f39c24b"];
[todo deleteInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');
todo.destroy();
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo.create_without_data('582570f38ac247004f39c24b')
todo.destroy()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = LeanObject::create("Todo", "582570f38ac247004f39c24b");
$todo->destroy();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject todo = AVObject.createWithoutData("Todo", "582570f38ac247004f39c24b");
todo.delete();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo", objectId: "582570f38ac247004f39c24b")
_ = todo.delete { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "JavaScript" %}
如果只需删除对象的一个属性，可以用 `unset`：

```js
var todo = AV.Object.createWithoutData('Todo', '582570f38ac247004f39c24b');

// priority 属性会被删除
todo.unset('priority');

// 保存对象
todo.save();
```
{% endif %}

{# Please note that use of `object.set(null)` to remove a field from an object is not recommended and will result in unexpected functionality. #}

{% call docs.alertWrap() %}
删除对象是一个较为敏感的操作，我们建议你阅读 [ACL 权限管理开发指南](acl-guide.html) 来了解潜在的风险。熟悉 class 级别、对象级别和字段级别的权限可以帮助你有效阻止未经授权的操作。
{% endcall %}

### 批量操作

可以在一次请求中包含多个构建、保存、删除和同步对象的操作：

{% if platform_name === "Objective-C" %}
```objc
// 批量构建和更新
+ (BOOL)saveAll:(NSArray *)objects error:(NSError **)error;
+ (void)saveAllInBackground:(NSArray *)objects
                      block:(AVBooleanResultBlock)block;

// 批量删除
+ (BOOL)deleteAll:(NSArray *)objects error:(NSError **)error;
+ (void)deleteAllInBackground:(NSArray *)objects
                        block:(AVBooleanResultBlock)block;

// 批量同步
+ (BOOL)fetchAll:(NSArray *)objects error:(NSError **)error;
+ (void)fetchAllInBackground:(NSArray *)objects
                       block:(AVArrayResultBlock)block;
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 创建一个保存所有 AV.Object 的数组
var objects = [];

// 批量构建和更新
AV.Object.saveAll(objects);

// 批量删除
AV.Object.destroyAll(objects);

// 批量同步
AV.Object.fetchAll(objects);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 批量构建和更新
leancloud.Object.save_all(list_of_objects)

# 批量删除
leancloud.Object.destroy_all(list_of_objects)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 批量构建和更新
LeanObject::saveAll()

// 批量删除
LeanObject::destroyAll()

// 批量同步
LeanObject::fetchAll()
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 批量构建和更新
saveAll()
saveAllInBackground()

// 批量删除
deleteAll()
deleteAllInBackground()

// 批量同步
fetchall()
fetchAllInBackground()
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// 创建一个保存所有 LCObject 的数组
let objects: [LCObject] = []

// 批量构建和更新
_ = LCObject.save(objects, completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})

// 批量删除
_ = LCObject.delete(objects, completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})

// 批量同步
_ = LCObject.fetch(objects, completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})
```
{% endif %}

下面的代码将所有 `Todo` 的 `isComplete` 设为 `true`：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query findObjectsInBackgroundWithBlock:^(NSArray *todos, NSError *error) {
    // 获取需要更新的 todo
    for (AVObject *todo in todos) {
        // 更新属性值
        todo[@"isComplete"] = @(YES);
    }
    // 批量更新
    [AVObject saveAllInBackground:todos];
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.find().then(function (todos) {
  // 获取需要更新的 todo
  todos.forEach(function (todo) {
    // 更新属性值
    todo.set('isComplete', true);
  });
  // 批量更新
  AV.Object.saveAll(todos);
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
# 获取需要更新的 todo
todo1 = Todo()
todo2 = Todo()
todo3 = Todo()
# 更新属性值
todo1.set('isComplete', True)
todo2.set('isComplete', True)
todo3.set('isComplete', True)
# 批量更新
Todo.save_all([todo1, todo2, todo3])
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$todos = $query->find();
// 获取需要更新的 todo
forEach ($todos as $todo) {
    // 更新属性值
    $todo->set("isComplete", true);
}
// 批量更新
LeanObject::saveAll($todos);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> todos) {
        // 获取需要更新的 todo
        for (AVObject todo : todos) {
            // 更新属性值
            todo.put("isComplete", true);
        }
        // 批量更新
        AVObject.saveAll(todos);
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
_ = query.find { (result) in
    switch result {
    case .success(objects: let todos):
        // 获取需要更新的 todo
        for todo in todos {
            do {
                // 更新属性值
                try todo.set("isComplete", value: true)
            } catch {
                print(error)
            }
        }
        // 批量更新
        let _ = LCObject.save(todos, completion: { (result) in
            switch result {
            case .success:
                break
            case .failure(error: let error):
                print(error)
            }
        })
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

虽然上述方法可以在一次请求中包含多个操作，每一个分别的保存或同步操作在计费时依然会被算作一次请求，而所有的删除操作则会被合并为一次请求。

{% if platform_name === "Objective-C" or platform_name === "Android / Java" or platform_name === "Swift" %}
### 后台运行

细心的开发者已经发现，在所有的示例代码中几乎都是用了异步来访问 LeanStorage 云端，形如{% if platform_name === "Objective-C" %} `xxxxInBackground` {% endif %}{% if platform_name === "Android / Java" %} `xxxxInBackground` {% endif %}{% if platform_name === "Swift" %}下面{% endif %}的用法都是提供给开发者在主线程调用用以实现后台运行的方法，因此开发者在主线程可以放心地调用这种命名方式的函数。另外，需要强调的是 **回调函数的代码是在主线程执行**。

{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo")

_ = todo.save { result in
    switch result {
    case .success:
        break
    case .failure(let error):
        print(error)
    }
}
```
{% endif %}
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "Android / Java" %}
### 离线存储对象

大多数保存功能可以立刻执行，并通知应用「保存完毕」。不过若不需要知道保存完成的时间，则可使用 `saveEventually` 来代替。

它的优点在于：如果用户目前尚未接入网络，`saveEventually` 会缓存设备中的数据，并在网络连接恢复后上传。如果应用在网络恢复之前就被关闭了，那么当它下一次打开时，LeanStorage 会再次尝试保存操作。

所有 `saveEventually`（或 `deleteEventually`）的相关调用，将按照调用的顺序依次执行。因此，多次对某一对象使用 `saveEventually` 是安全的。
{% endif %}

### 数据模型

对象之间可以产生关联。拿一个博客应用来说，一个 `Post` 对象可以与许多个 `Comment` 对象产生关联。LeanCloud 支持三种关系：一对一、一对多、多对多。

#### 一对一、一对多关系

一对一、一对多关系可以通过将 `{{ baseObjectName }}` 保存为另一个对象的属性值的方式产生。比如说，让博客应用中的一个 `Comment` 指向一个 `Post`。

下面的代码会创建一个含有单个 `Comment` 的 `Post`：

{% if platform_name === "Objective-C" %}
```objc
// 创建 post
AVObject *post = [[AVObject alloc] initWithClassName:@"Post"];
[post setObject:@"饿了……" forKey:@"title"];
[post setObject:@"中午去哪吃呢？" forKey:@"content"];

// 创建 comment
AVObject *comment = [[AVObject alloc] initWithClassName:@"Comment"];
[comment setObject:@"当然是肯德基啦！" forKey:@"content"];

// 将 post 设为 comment 的一个属性值
[comment setObject:post forKey:@"parent"];

// 保存 comment 会同时保存 post
[comment saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 创建 post
var post = new AV.Object('Post');
post.set('title', '饿了……');
post.set('content', '中午去哪吃呢？');

// 创建 comment
var comment = new AV.Object('Comment');
comment.set('content', '当然是肯德基啦！');

// 将 post 设为 comment 的一个属性值
comment.set('parent', post);

// 保存 comment 会同时保存 post
comment.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 创建 post
Post = leancloud.Object.extend('Post')
post = Post()
post.set('title', '饿了……')
post.set('content', '中午去哪吃呢？')

# 创建 comment
Comment = leancloud.Object.extend('Comment')
comment = Comment()
comment.set('content', '当然是肯德基啦！')

# 将 post 设为 comment 的一个属性值
comment.set('parent', post)

# 保存 comment 会同时保存 post
comment.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 创建 post
$post = new LeanObject("Post");
$post->set("title", "饿了……");
$post->set("content", "中午去哪吃呢？");

// 创建 comment
$comment = new LeanObject("Comment");
$comment->set("content", "当然是肯德基啦！")

// 将 post 设为 comment 的一个属性值
$comment->set("parent", $post)

// 保存 comment 会同时保存 post
$comment->save();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 创建 post
AVObject post = new AVObject("Post");
post.put("title", "饿了……");
post.put("content", "中午去哪吃呢？");

// 创建 comment
AVObject comment = new AVObject("Comment");
comment.put("content", "当然是肯德基啦！");

// 将 post 设为 comment 的一个属性值
comment.put("parent", post);

// 保存 comment 会同时保存 post
comment.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    // 创建 post
    let post = LCObject(className: "Post")
    try post.set("title", value: "饿了……")
    try post.set("content", value: "中午去哪吃呢？")

    // 创建 comment
    let comment = LCObject(className: "Comment")
    try comment.set("content", value: "当然是肯德基啦！")

    // 将 post 设为 comment 的一个属性值
    try comment.set("parent", value: post)

    // 保存 comment 会同时保存 post
    assert(comment.save().isSuccess)
} catch {
    print(error)
}
```
{% endif %}

云端存储时，会将被指向的对象用 `Pointer` 的形式存起来。你也可以用 `objectId` 来指向一个对象：

{% if platform_name === "Objective-C" %}
```objc
AVObject *post = [AVObject objectWithClassName:@"Post" objectId:@"57328ca079bc44005c2472d0"];
[comment setObject:post forKey:@"post"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var post = AV.Object.createWithoutData('Post', '57328ca079bc44005c2472d0');
comment.set('post', post);
```
{% endif %}
{% if platform_name === "Python" %}
```python
Post = leancloud.Object.extend('Post')
post = Post.create_without_data('57328ca079bc44005c2472d0')
comment.set('post', post)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$post = LeanObject::create("Post", "57328ca079bc44005c2472d0")
$comment->set("post", $post)
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject post = AVObject.createWithoutData("Post", "57328ca079bc44005c2472d0");
comment.put("post", post);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let post = LCObject(className: "Post", objectId: "57328ca079bc44005c2472d0")
try comment.set("post", value: post)
```
{% endif %}

请参阅 [关系查询](#关系查询) 来了解如何获取关联的对象。

#### 多对多关系

想要建立多对多关系，最简单的办法就是使用 **数组**。在大多数情况下，使用数组可以有效减少查询的次数，提升程序的运行效率。但如果有额外的属性需要附着于两个 class 之间的关联，那么使用 **中间表** 可能是更好的方式。注意这里说到的额外的属性是用来描述 class 之间的关系的，而不是任何单一的 class 的。

我们建议你在任何一个 class 的对象数量超出 100 的时候考虑使用中间表。

{% call docs.noteWrap() %}
我们知道设计数据模型并不容易，所以我们专门写了一篇 [数据模型设计指南](relation-guide.html) 来详细介绍这部分内容，推荐你去看一下。
{% endcall %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" or platform_name === "Swift" %}
### 序列化和反序列化

在实际的开发中，把 `{{ baseObjectName }}` 当作参数传递的时候，会涉及到复杂对象的拷贝的问题，因此 `{{ baseObjectName }}` 也提供了序列化和反序列化的方法。

序列化：

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [[AVObject alloc] initWithClassName:@"Todo"]; // 构建对象
[todo setObject:@"马拉松报名" forKey:@"title"]; // 设置名称
[todo setObject:@2 forKey:@"priority"]; // 设置优先级
[todo setObject:[AVUser currentUser] forKey:@"owner"]; // 这里就是一个 Pointer 类型，指向当前登录的用户

NSMutableDictionary *serializedJSONDictionary = [todo dictionaryForObject]; // 获取序列化后的字典
NSError *err;
NSData *jsonData = [NSJSONSerialization dataWithJSONObject:serializedJSONDictionary options:0 error:&err]; // 获取 JSON 数据
NSString *serializedString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding]; // 获取 JSON 字符串
// serializedString 的内容是：{"title":"马拉松报名","className":"Todo","priority":2}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var todo = new AV.Object('Todo'); // 构建对象
todo.set('title', '马拉松报名'); // 设置名称
todo.set('priority', 2); // 设置优先级
todo.set('owner', AV.User.current()); // 这里就是一个 Pointer 类型，指向当前登录的用户

// 将 AV.Object 对象反序列化成 JSON 对象
var json = todo.toFullJSON();
// 将 JSON 对象序列化为字符串
var serializedString = JSON.stringify(json);
```

{% call docs.noteWrap() %}
`AV.Object` 还提供了另一个方法 `toJSON()`。它们的区别是 `toJSON()` 得到的对象仅包含对象的 payload，一般用于展示，而 `toFullJSON()` 得到的对象包含了元数据，一般用于传输。在使用时请注意区分。
{% endcall %}
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject todo = new AVObject("Todo"); // 构建对象
todo.put("title", "马拉松报名"); // 设置名称
todo.put("priority", 2); // 设置优先级
todo.put("owner", AVUser.getCurrentUser()); // 这里就是一个 Pointer 类型，指向当前登录的用户
String serializedString = todo.toString();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    let todo = LCObject(className: "Todo")

    try todo.set("title", value: "马拉松报名")
    try todo.set("priority", value: 2)
    try todo.set("owner", value: LCApplication.default.currentUser)

    let data: Data
    if #available(iOS 11.0, *) {
        data = try NSKeyedArchiver.archivedData(withRootObject: todo, requiringSecureCoding: false)
    } else {
        data = NSKeyedArchiver.archivedData(withRootObject: todo)
    }
} catch {
    print(error)
}
```
{% endif %}

反序列化：

{% if platform_name === "Objective-C" %}
```objc
NSMutableDictionary *objectDictionary = [NSMutableDictionary dictionaryWithCapacity:10];// 声明一个 NSMutableDictionary
[objectDictionary setObject:@"马拉松报名" forKey:@"title"];
[objectDictionary setObject:@2 forKey:@"priority"];
[objectDictionary setObject:@"Todo" forKey:@"className"];

AVObject *todo = [AVObject objectWithDictionary:objectDictionary]; // 由 NSMutableDictionary 转化一个 AVObject

[todo saveInBackground]; // 保存到云端
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 将字符串反序列化为 JSON 对象
var json = JSON.parse(serializedString);
// 将 JSON 对象反序列化成 AV.Object 对象
var todo = AV.parseJSON(json);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject deserializedObject = AVObject.parseAVObject(serializedString);
deserializedObject.save(); // 保存到服务端
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    let todo = LCObject(className: "Todo")

    try todo.set("title", value: "马拉松报名")
    try todo.set("priority", value: 2)
    try todo.set("owner", value: LCApplication.default.currentUser)

    let data: Data
    if #available(iOS 11.0, *) {
        data = try NSKeyedArchiver.archivedData(withRootObject: todo, requiringSecureCoding: false)
    } else {
        data = NSKeyedArchiver.archivedData(withRootObject: todo)
    }

    let newTodo: LCObject? = try NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(data) as? LCObject
} catch {
    print(error)
}
```
{% endif %}
{% endif %}

{% if platform_name === "Python" %}
### 线程安全

`leancloud.Object` 目前不是线程安全的，因此请避免多个线程修改同一个 `leancloud.Object` 实例的操作。如果遇到必须多线程操作的情况，需要根据情况加锁。
{% endif %}

## 查询

我们已经了解到如何从云端获取单个 `{{ baseObjectName }}`，但你可能还会有一次性获取多个符合特定条件的 `{{ baseObjectName }}` 的需求，这时候就需要用到 `{{ baseQueryClassName }}` 了。

{# Before you continue, familiarize yourself with the models that are used in this guide. #}

### 基础查询

执行一次基础查询通常包括这些步骤：

1. 构建 `{{ baseQueryClassName }}`；
2. 向其添加查询条件；
3. 执行查询并获取包含满足条件的对象的数组。

下面的代码获取所有 `lastName` 为 `Smith` 的 `Student`：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Student"];
[query whereKey:@"lastName" equalTo:@"Smith"];
[query findObjectsInBackgroundWithBlock:^(NSArray *students, NSError *error) {
    // students 是包含满足条件的 Student 对象的数组
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Student');
query.equalTo('lastName', 'Smith');
query.find().then(function (students) {
  // students 是包含满足条件的 Student 对象的数组
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Student = leancloud.Object.extend('Student')
query = Student.query
query.equal_to('lastName', 'Smith')
student_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Student");
$query->equalTo("lastName", "Smith");
$students = $query->find();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Student");
query.whereEqualTo("lastName", "Smith");
query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> students) {
        // students 是包含满足条件的 Student 对象的数组
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Student")
query.whereKey("lastName", .equalTo("Smith"))
_ = query.find { result in
    switch result {
    case .success(objects: let students):
        // students 是包含满足条件的 Student 对象的数组
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

### 查询条件

可以给 `{{ baseObjectName }}` 添加不同的条件来改变获取到的结果。

下面的代码查询所有 `firstName` 不为 `Jack` 的对象：

{% if platform_name === "Objective-C" %}
```objc
[query whereKey:@"firstName" notEqualTo:@"Jack"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.notEqualTo('firstName', 'Jack');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.not_equal_to("firstName", 'Jack')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->notEqualTo("firstName", "Jack");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
query.whereNotEqualTo("firstName", "Jack");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("firstName", .notEqualTo("Jack"))
```
{% endif %}

对于能够排序的属性（比如数字、字符串），可以进行比较查询：

{% if platform_name === "Objective-C" %}
```objc
// 限制 age < 18
[query whereKey:@"age" lessThan:@18];

// 限制 age <= 18
[query whereKey:@"age" lessThanOrEqualTo:@18];

// 限制 age > 18
[query whereKey:@"age" greaterThan:@18];

// 限制 age >= 18
[query whereKey:@"age" greaterThanOrEqualTo:@18];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 限制 age < 18
query.lessThan('age', 18);

// 限制 age <= 18
query.lessThanOrEqualTo('age', 18);

// 限制 age > 18
query.greaterThan('age', 18);

// 限制 age >= 18
query.greaterThanOrEqualTo('age', 18);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 限制 age < 18
query.less_than('age', 18)

# 限制 age <= 18
query.less_than_or_equal_to('age', 18)

# 限制 age > 18
query.greater_than('age', 18)

# 限制 age >= 18
query.greater_than_or_equal_to('age', 18)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 限制 age < 18
$query->lessThan("age", 18);

// 限制 age <= 18
$query->lessThanOrEqualTo("age", 18);

// 限制 age > 18
$query->greaterThan("age", 18);

// 限制 age >= 18
$query->greaterThanOrEqualTo("age", 18);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 限制 age < 18
query.whereLessThan("age", 18);

// 限制 age <= 18
query.whereLessThanOrEqualTo("age", 18);

// 限制 age > 18
query.whereGreaterThan("age", 18);

// 限制 age >= 18
query.whereGreaterThanOrEqualTo("age", 18);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// 限制 age < 18
query.whereKey("age", .lessThan(18));

// 限制 age <= 18
query.whereKey("age", .lessThanOrEqualTo(18));

// 限制 age > 18
query.whereKey("age", .greaterThan(18));

// 限制 age >= 18
query.whereKey("age", .greaterThanOrEqualTo(18));
```
{% endif %}

可以在同一个查询中设置多个条件，这样可以获取满足所有条件的结果。可以理解为所有的条件是 `AND` 的关系：

{% if platform_name === "Objective-C" %}
```objc
[query whereKey:@"firstName" equalTo:@"Jack"];
[query whereKey:@"age" greaterThan:@18];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.equalTo('firstName', 'Jack');
query.greaterThan('age', 18);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.equal_to("firstName", 'Jack')
query.greater_than('age', 18)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->equalTo("firstName", "Jack");
$query->greaterThan("age", 18);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
query.whereEqualTo("firstName", "Jack");
query.whereGreaterThan("age", 18);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("firstName", .equalTo("Jack"))
query.whereKey("age", .greaterThan(18))
```
{% endif %}

可以通过指定 `limit` 限制返回结果的数量（默认为 `100`）：

{% if platform_name === "Objective-C" %}
```objc
// 最多获取 10 条结果
query.limit = 10;
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 最多获取 10 条结果
query.limit(10);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 最多获取 10 条结果
query.limit(10)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 最多获取 10 条结果
$query->limit(10);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 最多获取 10 条结果
query.limit(10);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// 最多获取 10 条结果
query.limit = 10
```
{% endif %}

{% call docs.noteWrap() %}
由于性能原因，`limit` 最大只能设为 `1000`。即使将其设为大于 `1000` 的数，云端也只会返回 1,000 条结果。
{% endcall %}

如果只需要一条结果，可以直接用 `{% if platform_name === "Objective-C" %}getFirstObject{% endif %}{% if platform_name === "JavaScript" %}first{% endif %}{% if platform_name === "Python" %}first{% endif %}{% if platform_name === "PHP" %}{% endif %}{% if platform_name === "Android / Java" %}getFirst{% endif %}{% if platform_name === "Swift" %}getFirst{% endif %}`：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query whereKey:@"priority" equalTo:@2];
[query getFirstObjectInBackgroundWithBlock:^(AVObject *todo, NSError *error) {
    // todo 是第一个满足条件的 Todo 对象
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.equalTo('priority', 2);
query.first().then(function (todo) {
  // todo 是第一个满足条件的 Todo 对象
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.equal_to('priority', 2)
todo = query.first()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->equalTo("priority", 2);
$todo = $query->first();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("priority", 2);
query.getFirstInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> todo) {
        // todo 是第一个满足条件的 Todo 对象
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("priority", .equalTo(2))
_ = query.getFirst { result in
    switch result {
    case .success(object: let todo):
        print(todo)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

可以通过设置 `skip` 来跳过一定数量的结果：

{% if platform_name === "Objective-C" %}
```objc
// 跳过前 20 条结果
query.skip = 20;
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 跳过前 20 条结果
query.skip(20);
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 跳过前 20 条结果
query.skip(20)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 跳过前 20 条结果
$query->skip(20);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 跳过前 20 条结果
query.skip(20);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// 跳过前 20 条结果
query.skip = 20
```
{% endif %}

把 `skip` 和 `limit` 结合起来，就能实现翻页功能：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query whereKey:@"priority" equalTo:@2];
query.limit = 10;
query.skip = 20;
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.equalTo('priority', 2);
query.limit(10);
query.skip(20);
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.equal_to('priority', 2)
query.limit(10)
query.skip(20)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->equalTo("priority", 2);
$query->limit(10);
$query->skip(20);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("priority", 2);
query.limit(10);
query.skip(20);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("priority", .equalTo(2))
query.limit = 10
query.skip = 20
```
{% endif %}

{% call docs.noteWrap() %}
需要注意的是，`skip` 的值越高，查询所需的时间就越长。作为替代方案，可以通过设置 `createdAt` 或 `updatedAt` 的范围来实现更高效的翻页，因为它们都自带索引。{# , or using the last value returned from an auto-increment field along with `limit` for the purpose of pagination #}
{% endcall %}

对于能够排序的属性，可以指定结果的排序规则：

{% if platform_name === "Objective-C" %}
```objc
// 按 createdAt 升序排列
[query orderByAscending:@"createdAt"];

// 按 createdAt 降序排列
[query orderByDescending:@"createdAt"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 按 createdAt 升序排列
query.ascending('createdAt');

// 按 createdAt 降序排列
query.descending('createdAt');
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 按 createdAt 升序排列
query.ascending('createdAt')

# 按 createdAt 降序排列
query.descending('createdAt')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 按 createdAt 升序排列
$query->ascend("createdAt");

// 按 createdAt 降序排列
$query->descend("createdAt");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 按 createdAt 升序排列
query.orderByAscending("createdAt");

// 按 createdAt 降序排列
query.orderByDescending("createdAt");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// 按 createdAt 升序排列
query.whereKey("createdAt", .ascending)

// 按 createdAt 降序排列
query.whereKey("createdAt", .descending)
```
{% endif %}

还可以为同一个查询添加多个排序规则；

{% if platform_name === "Objective-C" %}
```objc
[query addAscendingOrder:@"priority"];
[query addDescendingOrder:@"createdAt"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.addAscending('priority');
query.addDescending('createdAt');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.add_ascending('createdAt')
query.add_descending('priority')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->addAscend("priority");
$query->addDescend("createdAt");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
query.addAscendingOrder("priority");
query.addDescendingOrder("createdAt");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("priority", .ascending)
query.whereKey("createdAt", .descending)
```
{% endif %}

下面的代码可用于查找包含或不包含某一属性的对象：

{% if platform_name === "Objective-C" %}
```objc
// 查找包含 "images" 的对象
[query whereKeyExists:@"images"];

// 查找不包含 "images" 的对象
[query whereKeyDoesNotExist:@"images"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 查找包含 'images' 的对象
query.exists('images');

// 查找不包含 'images' 的对象
query.doesNotExist('images');
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 查找包含 'images' 的对象
query.exists('images')

# 查找不包含 'images' 的对象
query.does_not_exist('images')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 查找包含 "images" 的对象
$query->exists("images");

// 查找不包含 "images" 的对象
$query->notExists("images");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 查找包含 "images" 的对象
query.whereExists("images");

// 查找不包含 "images" 的对象
query.whereDoesNotExist("images");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// 查找包含 "images" 的对象
query.whereKey("images", .existed)

// 查找不包含 "images" 的对象
query.whereKey("images", .notExisted)
```
{% endif %}

{% if platform_name === "JavaScript" %}
可以用 `matchesKeyInQuery` 查找某一属性值为另一查询返回结果的对象。

比如说，你有一个用于存储国家和语言对应关系的 `Country` class，还有一个用于存储学生国籍的 `Student` class：

name | language
--- | ---
US | English
UK | English
China | Chinese

fullName | nationality
--- | ---
John Doe | US
Tom Sawyer | UK
Ming Li | China

下面的代码可以找到所有来自英语国家的学生：

```js
var studentQuery = new AV.Query('Student');
var countryQuery = new AV.Query('Country');
// 获取所有的英语国家
countryQuery.equalTo('language', 'English');
// 把 Student 的 nationality 和 Country 的 name 关联起来
studentQuery.matchesKeyInQuery('nationality', 'name', countryQuery);
studentQuery.find().then(function (students) {
  // students 包含 John Doe 和 Tom Sawyer
});
```
{% endif %}

可以通过 `{% if platform_name === "Objective-C" %}selectKeys{% endif %}{% if platform_name === "JavaScript" %}select{% endif %}{% if platform_name === "Python" %}select{% endif %}{% if platform_name === "PHP" %}select{% endif %}{% if platform_name === "Android / Java" %}selectKeys{% endif %}{% if platform_name === "Swift" %}.selected{% endif %}` 指定需要返回的属性。下面的代码只获取每个对象的 `title` 和 `content`（包括内置属性 `objectId`、`createdAt` 和 `updatedAt`）：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query selectKeys:@[@"title", @"content"]];
[query getFirstObjectInBackgroundWithBlock:^(AVObject *todo, NSError *error) {
    NSString *title = todo[@"title"]; // √
    NSString *content = todo[@"content"]; // √
    NSString *notes = todo[@"notes"]; // 会报错
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.select(['title', 'content']);
query.first().then(function (todo) {
  var title = todo.get('title'); // √
  var content = todo.get('content'); // √
  var notes = todo.get('notes'); // undefined
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.select('title', 'content')
todo = query.first()

title = todo.get('title') # √
content = todo.get('content') # √
notes = todo.get('notes') # None
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->select("title", "content");
$todo = $query->first();

$title = $todo->get("title"); // √
$content = $todo->get("content"); // √
$notes = $todo->get("notes"); // null
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.selectKeys(Arrays.asList("title", "content"));
query.getFirstInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject todo) {
        String title = todo.getString("title"); // √
        String content = todo.getString("content"); // √
        String notes = todo.getString("notes"); // 会报错
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("title", .selected)
query.whereKey("content", .selected)
_ = query.getFirst { result in
    switch result {
    case .success(object: let todo):
        let title = todo.get("title") // √
        let content = todo.get("content") // √
        let notes = todo.get("notes") // nil
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Java" or platform_name === "Swift" %}
对于未获取的属性，可以通过对结果中的对象进行 `{% if platform_name === "Objective-C" %}fetchInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}fetch{% endif %}{% if platform_name === "Python" %}fetch{% endif %}{% if platform_name === "Android / Java" %}fetchInBackground{% endif %}{% if platform_name === "Swift" %}fetch{% endif %}` 操作来获取。参见 [同步对象](#同步对象)。
{% endif %}

### 字符串查询

可以用 `{% if platform_name === "Objective-C" %}hasPrefix{% endif %}{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Python" %}startswith{% endif %}{% if platform_name === "PHP" %}startsWith{% endif %}{% if platform_name === "Android / Java" %}whereStartsWith{% endif %}{% if platform_name === "Swift" %}.prefixedBy{% endif %}` 来查找某一属性值以特定字符串开头的对象。和 SQL 中的 `LIKE` 一样，你可以利用索引带来的优势：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
// 相当于 SQL 中的 title LIKE 'lunch%'
[query whereKey:@"title" hasPrefix:@"lunch"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
// 相当于 SQL 中的 title LIKE 'lunch%'
query.startsWith('title', 'lunch');
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
# 相当于 SQL 中的 title LIKE 'lunch%'
query.startswith("title", "lunch")
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
// 相当于 SQL 中的 title LIKE 'lunch%'
$query->startsWith("title", "lunch");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
// 相当于 SQL 中的 title LIKE 'lunch%'
query.whereStartsWith("title", "lunch");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
// 相当于 SQL 中的 title LIKE 'lunch%'
query.whereKey("title", .prefixedBy("lunch"))
```
{% endif %}

可以用 `{% if platform_name === "Objective-C" %}containsString{% endif %}{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Python" %}contains{% endif %}{% if platform_name === "PHP" %}contains{% endif %}{% if platform_name === "Android / Java" %}whereContains{% endif %}{% if platform_name === "Swift" %}.matchedSubstring{% endif %}` 来查找某一属性值包含特定字符串的对象：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
// 相当于 SQL 中的 title LIKE '%lunch%'
[query whereKey:@"title" containsString:@"lunch"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
// 相当于 SQL 中的 title LIKE '%lunch%'
query.contains('title', 'lunch');
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
# 相当于 SQL 中的 title LIKE '%lunch%'
query.contains("title", "lunch")
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
// 相当于 SQL 中的 title LIKE '%lunch%'
$query->contains("title", "lunch");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
// 相当于 SQL 中的 title LIKE '%lunch%'
query.whereContains("title", "lunch");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
// 相当于 SQL 中的 title LIKE '%lunch%'
query.whereKey("title", .matchedSubstring("lunch"))
```
{% endif %}

和 `{% if platform_name === "Objective-C" %}hasPrefix{% endif %}{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Python" %}startswith{% endif %}{% if platform_name === "PHP" %}startsWith{% endif %}{% if platform_name === "Android / Java" %}whereStartsWith{% endif %}{% if platform_name === "Swift" %}.prefixedBy{% endif %}` 不同，`{% if platform_name === "Objective-C" %}containsString{% endif %}{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Python" %}contains{% endif %}{% if platform_name === "PHP" %}contains{% endif %}{% if platform_name === "Android / Java" %}whereContains{% endif %}{% if platform_name === "Swift" %}.matchedSubstring{% endif %}` 无法利用索引，因此不建议用于大型数据集。

{% call docs.noteWrap() %}
注意 `{% if platform_name === "Objective-C" %}hasPrefix{% endif %}{% if platform_name === "JavaScript" %}startsWith{% endif %}{% if platform_name === "Python" %}startswith{% endif %}{% if platform_name === "PHP" %}startsWith{% endif %}{% if platform_name === "Android / Java" %}whereStartsWith{% endif %}{% if platform_name === "Swift" %}.prefixedBy{% endif %}` 和 `{% if platform_name === "Objective-C" %}containsString{% endif %}{% if platform_name === "JavaScript" %}contains{% endif %}{% if platform_name === "Python" %}contains{% endif %}{% if platform_name === "PHP" %}contains{% endif %}{% if platform_name === "Android / Java" %}whereContains{% endif %}{% if platform_name === "Swift" %}.matchedSubstring{% endif %}` 都是 **区分大小写** 的，所以上述查询会忽略 `Lunch`、`LUNCH` 等字符串。
{% endcall %}

如果想查找某一属性值不包含特定字符串的对象，可以使用 `{% if platform_name === "Objective-C" %}matchesRegex{% endif %}{% if platform_name === "JavaScript" %}matches{% endif %}{% if platform_name === "Python" %}matched{% endif %}{% if platform_name === "PHP" %}matches{% endif %}{% if platform_name === "Android / Java" %}whereMatches{% endif %}{% if platform_name === "Swift" %}.matchedPattern{% endif %}` 进行基于正则表达式的查询：

{% if platform_name === "Objective-C" %}
<pre><code class="lang-objc">AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
// "title" 不包含 "ticket"（区分大小写）
[query whereKey:@"title" matchesRegex:@"{{ regex() | safe }}];    
</code></pre>
{% endif %}
{% if platform_name === "JavaScript" %}
<pre><code class="lang-js">var query = new AV.Query('Todo');
// 'title' 不包含 'ticket'（区分大小写）
var regExp = new RegExp('{{ regex(true) | safe }}, 'i');
query.matches('title', regExp);
</code></pre>
{% endif %}
{% if platform_name === "Python" %}
<pre><code class="lang-python">Todo = leancloud.Object.extend('Todo')
query = Todo.query
# 'title' 不包含 'ticket'（区分大小写）
query.matched('title', '{{ regex(true) | safe }})
</code></pre>
{% endif %}
{% if platform_name === "PHP" %}
<pre><code class="lang-php">$query = new Query("Todo");
// "title" 不包含 "ticket"（区分大小写）
$query->matches("title","{{ regex() | safe }});
</code></pre>
{% endif %}
{% if platform_name === "Android / Java" %}
<pre><code class="lang-java">AVQuery<AVObject> query = new AVQuery<>("Todo");
// "title" 不包含 "ticket"（区分大小写）
query.whereMatches("title","{{ regex() | safe }});
</code></pre>
{% endif %}
{% if platform_name === "Swift" %}
<pre><code class="lang-swift">let query = LCQuery(className: "Todo")
// "title" 不包含 "ticket"（区分大小写）
query.whereKey("title", .matchedPattern("{{ regex() | safe }}, option: nil))
</code></pre>
{% endif %}

{# 2016-12-29 DO NOT USE markdown to rewrite the previous block #}

不过我们并不推荐大量使用这类查询，尤其是对于包含超过 100,000 个对象的 class，{# LeanCloud restricts how many such operations can be run on a particular app at any given time. #}因为这类查询无法利用索引，实际操作中云端会遍历所有对象来获取结果。如果有进行全文搜索的需求，可以了解一下 [应用内搜索](app_search_guide.html) 功能。

{% call docs.noteWrap() %}
使用查询时如果遇到性能问题，可参阅 [查询性能优化](#查询性能优化)。
{% endcall %}

### 数组查询

下面的代码查找所有数组属性 `tags` 包含 `工作` 的对象：

{% if platform_name === "Objective-C" %}
```objc
[query whereKey:@"tags" equalTo:@"工作"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.equalTo('tags', '工作');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.equal_to('tags', '工作')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->equalTo("tags", "工作");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
query.whereEqualTo("tags", "工作");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("tags", .equalTo("工作"))
```
{% endif %}

下面的代码查找所有数组属性 `tags` **同时包含** `工作`、`销售` 和 `会议` 的对象：

{% if platform_name === "Objective-C" %}
```objc
[query whereKey:@"tags" containsAllObjectsInArray:[NSArray arrayWithObjects:@"工作", @"销售", @"会议", nil]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.containsAll('tags', ['工作', '销售', '会议']);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.contains_all('tags', ['工作', '销售', '会议'])
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->containsAll("tags", array("工作", "销售", "会议"));
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
query.whereContainsAll("tags", Arrays.asList("工作", "销售", "会议"));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("tags", .containedAllIn(["工作", "销售", "会议"]))
```
{% endif %}

如需获取某一属性值包含一列值中任意一个值的对象，可以直接用 `{% if platform_name === "Objective-C" %}containedIn{% endif %}{% if platform_name === "JavaScript" %}containedIn{% endif %}{% if platform_name === "Python" %}contained_in{% endif %}{% if platform_name === "PHP" %}containedIn{% endif %}{% if platform_name === "Android / Java" %}whereContainedIn{% endif %}{% if platform_name === "Swift" %}.containedIn{% endif %}` 而无需执行多次查询。下面的代码构建的查询会查找所有 `priority` 为 `1` **或** `2` 的 todo 对象：

{% if platform_name === "Objective-C" %}
```objc
// 单个查询
AVQuery *priorityOneOrTwo = [AVQuery queryWithClassName:@"Todo"];
[priorityOneOrTwo whereKey:@"priority" containedIn:[NSArray arrayWithObjects:@1, @2, nil]];
// 这样就可以了 :)

// ---------------
//       vs.
// ---------------

// 多个查询
AVQuery *priorityOne = [AVQuery queryWithClassName:@"Todo"];
[priorityOne whereKey:@"priority" equalTo:@1];

AVQuery *priorityTwo = [AVQuery queryWithClassName:@"Todo"];
[priorityTwo whereKey:@"priority" equalTo:@2];

AVQuery *priorityOneOrTwo = [AVQuery orQueryWithSubqueries:[NSArray arrayWithObjects:priorityOne, priorityTwo, nil]];
// 好像有些繁琐 :(
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 单个查询
var priorityOneOrTwo = new AV.Query('Todo');
priorityOneOrTwo.containedIn('priority', [1, 2]);
// 这样就可以了 :)

// ---------------
//       vs.
// ---------------

// 多个查询
var priorityOne = new AV.Query('Todo');
priorityOne.equalTo('priority', 1);

var priorityTwo = new AV.Query('Todo');
priorityTwo.equalTo('priority', 2);

var priorityOneOrTwo = AV.Query.or(priorityOne, priorityTwo);
// 好像有些繁琐 :(
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 单个查询
Todo = leancloud.Object.extend('Todo')
priority_one_or_two = Todo.query
priority_one_or_two.contained_in('priority', [1, 2])
# 这样就可以了 :)

# ---------------
#       vs.
# ---------------

# 多个查询
Todo = leancloud.Object.extend('Todo')

priority_one = Todo.query
priority_one.equal_to('priority', 1)

priority_two = Todo.query
priority_two.equal_to('priority', 2)

priority_one_or_two = leancloud.Query.or_(priority_one, priority_two)
# 好像有些繁琐 :(
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 单个查询
$priorityOneOrTwo = new Query("Todo");
$priorityOneOrTwo->containedIn("priority", array(1, 2));
// 这样就可以了 :)

// ---------------
//       vs.
// ---------------

// 多个查询
$priorityOne = new Query("Todo");
$priorityOne->equalTo("priority", 1);

$priorityTwo = new Query("Todo");
$priorityTwo->equalTo("priority", 2);

$query = Query::orQuery($priorityOne, $priorityTwo);
// 好像有些繁琐 :(
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 单个查询
AVQuery<AVObject> priorityOneOrTwo = new AVQuery<>("Todo");
priorityOneOrTwo.whereContainedIn("priority", Arrays.asList(1, 2));
// 这样就可以了 :)

// ---------------
//       vs.
// ---------------

// 多个查询
final AVQuery<AVObject> priorityOne = new AVQuery<>("Todo");
priorityOne.whereEqualTo("priority", 1);

final AVQuery<AVObject> priorityTwo = new AVQuery<>("Todo");
priorityTwo.whereEqualTo("priority", 2);

AVQuery<AVObject> priorityOneOrTwo = AVQuery.or(Arrays.asList(priorityOne, priorityTwo));
// 好像有些繁琐 :(
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// 单个查询
let priorityOneOrTwo = LCQuery(className: "Todo")
priorityOneOrTwo.whereKey("priority", .containedIn([1, 2]))
// 这样就可以了 :)

// ---------------
//       vs.
// ---------------

// 多个查询
let priorityOne = LCQuery(className: "Todo")
priorityOne.whereKey("priority", .equalTo(1))

let priorityTwo = LCQuery(className: "Todo")
priorityTwo.whereKey("priority", .equalTo(2))

let priorityOneOrTwo = priorityOne.or(priorityTwo)
// 好像有些繁琐 :(
```
{% endif %}

反过来，还可以用 `{% if platform_name === "Objective-C" %}notContainedIn{% endif %}{% if platform_name === "JavaScript" %}notContainedIn{% endif %}{% if platform_name === "Python" %}not_contained_in{% endif %}{% if platform_name === "PHP" %}notContainedIn{% endif %}{% if platform_name === "Android / Java" %}whereNotContainedIn{% endif %}{% if platform_name === "Swift" %}.notContainedIn{% endif %}` 来获取某一属性值不包含一列值中任何一个的对象。

### 关系查询

查询关联数据有很多种方式，常见的一种是查询某一属性值为特定 `{{ baseObjectName }}` 的对象，这时可以像其他查询一样直接用 `{% if platform_name === "Objective-C" %}equalTo{% endif %}{% if platform_name === "JavaScript" %}equalTo{% endif %}{% if platform_name === "Python" %}equal_to{% endif %}{% if platform_name === "PHP" %}equalTo{% endif %}{% if platform_name === "Android / Java" %}whereEqualTo{% endif %}{% if platform_name === "Swift" %}.equalTo{% endif %}`。比如说，如果每一条博客评论 `Comment` 都有一个 `post` 属性用来存放原文 `Post`，则可以用下面的方法获取所有与某一 `Post` 相关联的评论：

{% if platform_name === "Objective-C" %}
```objc
AVObject *post = [AVObject objectWithClassName:@"Post" objectId:@"57328ca079bc44005c2472d0"];
AVQuery *query = [AVQuery queryWithClassName:@"Comment"];
[query whereKey:@"post" equalTo:post];
[query findObjectsInBackgroundWithBlock:^(NSArray *comments, NSError *error) {
    // comments 包含与 post 相关联的评论
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var post = AV.Object.createWithoutData('Post', '57328ca079bc44005c2472d0');
var query = new AV.Query('Comment');
query.equalTo('post', post);
query.find().then(function (comments) {
  // comments 包含与 post 相关联的评论
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Post = leancloud.Object.extend('Post')
post = Post.create_without_data('57328ca079bc44005c2472d0')
query = leancloud.Query('Comment')
query.equal_to('post', post)
comment_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$post = LeanObject::create("Post", "57328ca079bc44005c2472d0")
$query = new Query("Comment");
$query->equalTo("post", $post);
$comments = $query->find();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject post = AVObject.createWithoutData("Post", "57328ca079bc44005c2472d0");
AVQuery<AVObject> query = new AVQuery<>("Comment");
query.whereEqualTo("post", post);
query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> comments) {
        // comments 包含与 post 相关联的评论
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let post = LCObject(className: "Post", objectId: "57328ca079bc44005c2472d0")
let query = LCQuery(className: "Comment")
query.whereKey("post", .equalTo(post))
_ = query.find { result in
    switch result {
    case .success(objects: let comments):
        // comments 包含与 post 相关联的评论
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

如需获取某一属性值为另一查询结果中任一 `{{ baseObjectName }}` 的对象，可以用 `{% if platform_name === "Objective-C" %}matchesQuery{% endif %}{% if platform_name === "JavaScript" %}matchesQuery{% endif %}{% if platform_name === "Python" %}matches_query{% endif %}{% if platform_name === "PHP" %}matchesInQuery{% endif %}{% if platform_name === "Android / Java" %}whereMatchesQuery{% endif %}{% if platform_name === "Swift" %}.matchedQuery{% endif %}`。下面的代码构建的查询可以找到所有包含图片的博客文章的评论：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *innerQuery = [AVQuery queryWithClassName:@"Post"];
[innerQuery whereKeyExists:@"images"];

AVQuery *query = [AVQuery queryWithClassName:@"Comment"];
[query whereKey:@"post" matchesQuery:innerQuery];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var innerQuery = new AV.Query('Post');
innerQuery.exists('image');

var query = new AV.Query('Comment');
query.matchesQuery('post', innerQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
inner_query = leancloud.Query('Post')
inner_query.exists('images')

query = leancloud.Query('Comment')
query.matches_query('post', inner_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$innerQuery = new Query("Post");
$innerQuery->exists("images");

$query = new Query("Comment");
$query->matchesInQuery("post", $innerQuery);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> innerQuery = new AVQuery<>("Post");
innerQuery.whereExists("image");

AVQuery<AVObject> query = new AVQuery<>("Comment");
query.whereMatchesQuery("post", innerQuery);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let innerQuery = LCQuery(className: "Post")
innerQuery.whereKey("image", .existed)

let query = LCQuery(className: "Comment")
query.whereKey("post", .matchedQuery(innerQuery))
```
{% endif %}

如需获取某一属性值不是另一查询结果中任一 `{{ baseObjectName }}` 的对象，则使用 `{% if platform_name === "Objective-C" %}doesNotMatchQuery{% endif %}{% if platform_name === "JavaScript" %}doesNotMatchQuery{% endif %}{% if platform_name === "Python" %}does_not_match_query{% endif %}{% if platform_name === "PHP" %}notMatchInQuery{% endif %}{% if platform_name === "Android / Java" %}whereDoesNotMatchQuery{% endif %}{% if platform_name === "Swift" %}.notMatchedQuery{% endif %}`。

有时候可能需要获取来自另一个 class 的数据而不想进行额外的查询，此时可以在同一个查询上使用 `{% if platform_name === "Objective-C" %}includeKey{% endif %}{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Python" %}include{% endif %}{% if platform_name === "PHP" %}_include{% endif %}{% if platform_name === "Android / Java" %}include{% endif %}{% if platform_name === "Swift" %}.included{% endif %}`。下面的代码查找最新发布的 10 条评论，并包含各自对应的博客文章：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Comment"];

// 获取最新发布的
[query orderByDescending:@"createdAt"];

// 只获取 10 条
query.limit = 10;

// 同时包含博客文章
[query includeKey:@"post"];

[query findObjectsInBackgroundWithBlock:^(NSArray *comments, NSError *error) {
    // comments 包含最新发布的 10 条评论，包含各自对应的博客文章
    for (AVObject *comment in comments) {
        // 该操作无需网络连接
        AVObject *post = comment[@"post"];
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Comment');

// 获取最新发布的
query.descending('createdAt');

// 只获取 10 条
query.limit(10);

// 同时包含博客文章
query.include('post');

query.find().then(function (comments) {
  // comments 包含最新发布的 10 条评论，包含各自对应的博客文章
  comments.forEach(function (comment) {
    // 该操作无需网络连接
    var post = comment.get('post');
  });
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('Comment')

# 获取最新发布的
query.add_descending('createdAt')

# 只获取 10 条
query.limit(10)

# 同时包含博客文章
query.include('post')

comment_list = query.find()
for comment in comment_list:
    # 该操作无需网络连接
    post = comment.get('post')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Comment");

// 获取最新发布的
$query->descend("createdAt");

// 只获取 10 条
$query->limit(10);

// 同时包含博客文章
$query->_include("post");

$comments = $query->find();
forEach($comments as $comment) {
    // 该操作无需网络连接
    $post = $comment->get("post");
}
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Comment");

// 获取最新发布的
query.orderByDescending("createdAt");

// 只获取 10 条
query.limit(10);

// 同时包含博客文章
query.include("post");

query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> comments) {
        // comments 包含最新发布的 10 条评论，包含各自对应的博客文章
        for (AVObject comment : comments) {
            // 该操作无需网络连接
            AVObject post = comment.getAVObject("post");
        }
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Comment")

// 获取最新发布的
query.whereKey("createdAt", .descending)

// 只获取 10 条
query.limit = 10

// 同时包含博客文章
query.whereKey("post", .included)

_ = query.find { result in
    switch result {
    case .success(objects: let comments):
        // comments 包含最新发布的 10 条评论，包含各自对应的博客文章
        for comment in comments {
            // 该操作无需网络连接
            let post = comment.get("post") as? LCObject
        }
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

可以用 dot 符号（`.`）来获取多级关系。比如说，在获取评论对应文章的同时获取文章作者：

{% if platform_name === "Objective-C" %}
```objc
[query includeKey:@"post.author"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.include('post.author');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.include('post.author')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->_include("post.author");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
query.include("post.author");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("post.author", .included)
```
{% endif %}

可以在同一查询上应用多次 `{% if platform_name === "Objective-C" %}includeKey{% endif %}{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Python" %}include{% endif %}{% if platform_name === "PHP" %}_include{% endif %}{% if platform_name === "Android / Java" %}include{% endif %}{% if platform_name === "Swift" %}.included{% endif %}` 以包含多个属性。通过这种方法获取到的对象同样接受 `{% if platform_name === "Objective-C" %}getFirstObject{% endif %}{% if platform_name === "JavaScript" %}first{% endif %}{% if platform_name === "Python" %}first{% endif %}{% if platform_name === "PHP" %}{% endif %}{% if platform_name === "Android / Java" %}getFirst{% endif %}{% if platform_name === "Swift" %}getFirst{% endif %}`{% if platform_name === "JavaScript" or platform_name === "Python" or platform_name === "Swift" %}、`get`{% endif %} 等 `{{ baseQueryClassName }}` 辅助方法。

{% call docs.noteWrap() %}
通过 `{% if platform_name === "Objective-C" %}includeKey{% endif %}{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Python" %}include{% endif %}{% if platform_name === "PHP" %}_include{% endif %}{% if platform_name === "Android / Java" %}include{% endif %}{% if platform_name === "Swift" %}.included{% endif %}` 进行多级查询的方式不适用于数组属性内部的 `{{ baseObjectName }}`，只能包含到数组本身。
{% endcall %}

dot 符号（`.`）还可用于 `{% if platform_name === "Objective-C" %}selectKeys{% endif %}{% if platform_name === "JavaScript" %}select{% endif %}{% if platform_name === "Python" %}select{% endif %}{% if platform_name === "PHP" %}select{% endif %}{% if platform_name === "Android / Java" %}selectKeys{% endif %}{% if platform_name === "Swift" %}.selected{% endif %}` 以限制返回的关联对象的属性：

{% if platform_name === "Objective-C" %}
```objc
[query selectKeys:@[@"post.author.firstName"]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
query.select('post.author.firstName');
```
{% endif %}
{% if platform_name === "Python" %}
```python
query.select('post.author.firstName')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query->select("post.author.firstName");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
query.selectKeys(Arrays.asList("post.author.firstName"));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
query.whereKey("post.author.firstName", .selected)
```
{% endif %}

#### 关系查询的注意事项

LeanCloud 云端使用的并非关系型数据库，无法做到真正的联表查询，所以实际的处理方式是：先执行内嵌/子查询（和普通查询一样，`limit` 默认为 `100`，最大 `1000`），然后将子查询的结果填入主查询的对应位置，再执行主查询。如果子查询匹配到的记录数量超出 `limit`，且主查询有其他查询条件，那么可能会出现没有结果或结果不全的情况，因为只有 `limit` 数量以内的结果会被填入主查询。

我们建议采用以下方案进行改进：

- 确保子查询的结果在 100 条以下，如果在 100 至 1,000 条之间的话请将子查询的 `limit` 设为 `1000`。
- 将需要查询的字段冗余到主查询所在的表上。
- 进行多次查询，每次在子查询上设置不同的 `skip` 值来遍历所有记录（注意 `skip` 的值较大时可能会引发性能问题，因此不是很推荐）。

### 统计总数量

如果只需知道有多少对象匹配查询条件而无需获取对象本身，可使用 `{% if platform_name === "Objective-C" %}countObjectsInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}count{% endif %}{% if platform_name === "Python" %}count{% endif %}{% if platform_name === "PHP" %}count{% endif %}{% if platform_name === "Android / Java" %}count{% endif %}{% if platform_name === "Swift" %}count{% endif %}` 来代替 `{% if platform_name === "Objective-C" %}findObjectsInBackgroundWithBlock{% endif %}{% if platform_name === "JavaScript" %}find{% endif %}{% if platform_name === "Python" %}find{% endif %}{% if platform_name === "PHP" %}find{% endif %}{% if platform_name === "Android / Java" %}findInBackground{% endif %}{% if platform_name === "Swift" %}find{% endif %}`。比如说，查询有多少个已完成的 todo：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query whereKey:@"isComplete" equalTo:@(YES)];
[query countObjectsInBackgroundWithBlock:^(NSInteger count, NSError *error) {
    NSLog(@"%ld 个 todo 已完成。", count);
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.equalTo('isComplete', true);
query.count().then(function (count) {
  console.log(count + " 个 todo 已完成。");
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
query = Todo.query
query.equal_to('isComplete', True)
count = query.count()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$query->equalTo("isComplete", true);
$count = $query->count();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("isComplete", true);
query.countInBackground().subscribe(new Observer<Integer>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(Integer count) {
        System.out.println(count + " 个 todo 已完成。");
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
query.whereKey("isComplete", .equalTo(true))
let count = query.count()
```
{% endif %}

### 组合查询

组合查询就是把诸多查询条件用一定逻辑合并到一起（`OR` 或 `AND`）再交给云端去查询。

{% call docs.noteWrap() %}
组合查询不支持在子查询中包含 `GeoPoint` 或其他非过滤性的限制（例如 `near`、`withinGeoBox`、`limit`、`skip`、`ascending`、`descending`、`include`）。
{% endcall %}

#### OR 查询

OR 操作表示多个查询条件符合其中任意一个即可。 例如，查询优先级大于等于 `3` 或者已经完成了的 todo：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *priorityQuery = [AVQuery queryWithClassName:@"Todo"];
[priorityQuery whereKey:@"priority" greaterThanOrEqualTo:@3];

AVQuery *isCompleteQuery = [AVQuery queryWithClassName:@"Todo"];
[isCompleteQuery whereKey:@"isComplete" equalTo:@(YES)];

AVQuery *query = [AVQuery orQueryWithSubqueries:[NSArray arrayWithObjects:priorityQuery, isCompleteQuery, nil]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var priorityQuery = new AV.Query('Todo');
priorityQuery.greaterThanOrEqualTo('priority', 3);

var isCompleteQuery = new AV.Query('Todo');
isCompleteQuery.equalTo('isComplete', true);

var query = AV.Query.or(priorityQuery, isCompleteQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')

priority_query = Todo.query
priority_query.greater_than_or_equal_to('priority', 3)

is_complete_query = Todo.query
is_complete_query.equal_to('isComplete', True)

query = leancloud.Query.or_(priority_query, is_complete_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$priorityQuery = new Query("Todo");
$priorityQuery->greaterThanOrEqualTo("priority", 3);

$isCompleteQuery = new Query("Todo");
$isCompleteQuery->equalTo("isComplete", true);

$query = Query::orQuery($priorityQuery, $isCompleteQuery);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
final AVQuery<AVObject> priorityQuery = new AVQuery<>("Todo");
priorityQuery.whereGreaterThanOrEqualTo("priority", 3);

final AVQuery<AVObject> isCompleteQuery = new AVQuery<>("Todo");
isCompleteQuery.whereEqualTo("isComplete", true);

AVQuery<AVObject> query = AVQuery.or(Arrays.asList(priorityQuery, isCompleteQuery));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let priorityQuery = LCQuery(className: "Todo")
priorityQuery.whereKey("priority", .greaterThanOrEqualTo(3))

let isCompleteQuery = LCQuery(className: "Todo")
isCompleteQuery.whereKey("isComplete", .equalTo(true))

let query = priorityQuery.or(isCompleteQuery)
```
{% endif %}

{% call docs.noteWrap() %}
使用 OR 查询时，子查询中不能包含 `GeoPoint` 相关的查询。
{% endcall %}

#### AND 查询

使用 AND 查询的效果等同于往 `{{ baseQueryClassName }}` 添加多个条件。下面的代码构建的查询会查找创建时间在 `2016-11-13` 和 `2016-12-02` 之间的 todo：

{% if platform_name === "Objective-C" %}
```objc
NSDate *(^dateFromString)(NSString *string) = ^(NSString *string) {
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd"];
    return [dateFormatter dateFromString:string];
};

AVQuery *startDateQuery = [AVQuery queryWithClassName:@"Todo"];
[startDateQuery whereKey:@"createdAt" greaterThanOrEqualTo:dateFromString(@"2016-11-13")];

AVQuery *endDateQuery = [AVQuery queryWithClassName:@"Todo"];
[endDateQuery whereKey:@"createdAt" lessThan:dateFromString(@"2016-12-03")];

AVQuery *query = [AVQuery andQueryWithSubqueries:[NSArray arrayWithObjects:startDateQuery, endDateQuery, nil]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var startDateQuery = new AV.Query('Todo');
startDateQuery.greaterThanOrEqualTo('createdAt', new Date('2016-11-13 00:00:00'));

var endDateQuery = new AV.Query('Todo');
endDateQuery.lessThan('createdAt', new Date('2016-12-03 00:00:00'));

var query = AV.Query.and(startDateQuery, endDateQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

Todo = leancloud.Object.extend('Todo')

start_date_query = Todo.query
start_date_query.greater_than_or_equal_to('createdAt', datetime(2016, 11, 13))

end_date_query = Todo.query
end_date_query.less_than('createdAt', datetime(2016, 12, 3))

query = leancloud.Query.and_(start_date_query, end_date_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$startDate = new \DateTime("2016-11-13");
$startDateQuery = new Query("Todo");
$startDateQuery->greaterThanOrEqualTo("createdAt", $startDate);

$endDate = new \DateTime("2016-12-03");
$endDateQuery = new Query("Todo");
$endDateQuery->lessThan("createdAt", $endDate);

$query = Query::andQuery($startDateQuery, $endDateQuery);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}

final AVQuery<AVObject> startDateQuery = new AVQuery<>("Todo");
startDateQuery.whereGreaterThanOrEqualTo("createdAt", getDateWithDateString("2016-11-13"));

final AVQuery<AVObject> endDateQuery = new AVQuery<>("Todo");
endDateQuery.whereLessThan("createdAt", getDateWithDateString("2016-12-03"));

AVQuery<AVObject> query = AVQuery.and(Arrays.asList(startDateQuery, endDateQuery));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let dateFromString: (String) -> Date? = { string in
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    return dateFormatter.date(from: string)
}

let startDateQuery = LCQuery(className: "Todo")
startDateQuery.whereKey("createdAt", .greaterThanOrEqualTo(dateFromString("2016-11-13")))

let endDateQuery = LCQuery(className: "Todo")
endDateQuery.whereKey("createdAt", .lessThan(dateFromString("2016-12-03")))

let query = startDateQuery.and(endDateQuery)
```
{% endif %}

单独使用 AND 查询跟使用基础查询相比并没有什么不同，不过当把它和 OR 查询结合在一起的时候就不一样了。下面的代码构建的查询可以查找所有今天创建的 todo 中没有 `location` 的或 `priority` 为 `3` 的：

{% if platform_name === "Objective-C" %}
```objc
NSDate *(^dateFromString)(NSString *string) = ^(NSString *string) {
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd"];
    return [dateFormatter dateFromString:string];
};

AVQuery *createdAtQuery = [AVQuery queryWithClassName:@"Todo"];
[createdAtQuery whereKey:@"createdAt" greaterThanOrEqualTo:dateFromString(@"2018-04-30")];
[createdAtQuery whereKey:@"createdAt" lessThan:dateFromString(@"2018-05-01")];

AVQuery *locationQuery = [AVQuery queryWithClassName:@"Todo"];
[locationQuery whereKeyDoesNotExist:@"location"];

AVQuery *priorityQuery = [AVQuery queryWithClassName:@"Todo"];
[priorityQuery whereKey:@"priority" equalTo:@3];

AVQuery *orQuery = [AVQuery orQueryWithSubqueries:[NSArray arrayWithObjects:locationQuery, priorityQuery, nil]];
AVQuery *query = [AVQuery andQueryWithSubqueries:[NSArray arrayWithObjects:createdAtQuery, orQuery, nil]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var createdAtQuery = new AV.Query('Todo');
createdAtQuery.greaterThanOrEqualTo('createdAt', new Date('2018-04-30'));
createdAtQuery.lessThan('createdAt', new Date('2018-05-01'));

var locationQuery = new AV.Query('Todo');
locationQuery.doesNotExist('location');

var priorityQuery = new AV.Query('Todo');
priorityQuery.equalTo('priority', 3);

var orQuery = AV.Query.or(locationQuery, priorityQuery);
var query = AV.Query.and(createdAtQuery, orQuery);
```
{% endif %}
{% if platform_name === "Python" %}
```python
from datetime import datetime

Todo = leancloud.Object.extend('Todo')

created_at_query = Todo.query
created_at_query.greater_than_or_equal_to('createdAt', datetime(2018, 4, 30))
created_at_query.less_than('createdAt', datetime(2018, 5, 1))

location_query = Todo.query
location_query.does_not_exist('location')

priority_query = Todo.query
priority_query.equal_to('priority', 3)

or_query = leancloud.Query.or_(location_query, priority_query)
query = leancloud.Query.and_(created_at_query, or_query)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$startDate = new \DateTime("2018-04-30");
$endDate = new \DateTime("2018-05-01");
$createdAtQuery = new Query("Todo");
$createdAtQuery->greaterThanOrEqualTo("createdAt", $startDate);
$createdAtQuery->lessThan("createdAt", $endDate);

$locationQuery = new Query("Todo");
$locationQuery->notExists("location");

$priorityQuery = new Query("Todo");
$priorityQuery->equalTo("priority", 3);

$orQuery = Query::orQuery($locationQuery, $priorityQuery)
$query = Query::andQuery($createdAtQuery, $orQuery);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
Date getDateWithDateString(String dateString) {
    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    Date date = dateFormat.parse(dateString);
    return date;
}

final AVQuery<AVObject> createdAtQuery = new AVQuery<>("Todo");
createdAtQuery.whereGreaterThanOrEqualTo("createdAt", getDateWithDateString("2018-04-30"));
createdAtQuery.whereLessThan("createdAt", getDateWithDateString("2018-05-01"));

final AVQuery<AVObject> locationQuery = new AVQuery<>("Todo");
locationQuery.whereDoesNotExist("location");

final AVQuery<AVObject> priorityQuery = new AVQuery<>("Todo");
priorityQuery.whereEqualTo("priority", 3);

AVQuery<AVObject> orQuery = AVQuery.or(Arrays.asList(locationQuery, priorityQuery));
AVQuery<AVObject> query = AVQuery.and(Arrays.asList(createdAtQuery, orQuery));
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let dateFromString: (String) -> Date? = { string in
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyy-MM-dd"
    return dateFormatter.date(from: string)
}

let createdAtQuery = LCQuery(className: "Todo")
createdAtQuery.whereKey("createdAt", .greaterThanOrEqualTo(dateFromString("2018-04-30")))
createdAtQuery.whereKey("createdAt", .lessThan(dateFromString("2018-05-01")))

let locationQuery = LCQuery(className: "Todo")
locationQuery.whereKey("location", .notExisted)

let priorityQuery = LCQuery(className: "Todo")
priorityQuery.whereKey("priority", .equalTo(3))

let orQuery = locationQuery.or(priorityQuery)
let query = createdAtQuery.and(orQuery)
```
{% endif %}

{% if platform_name === "Objective-C" %}
### 缓存查询

缓存一些查询的结果到磁盘上，这可以让你在离线的时候，或者应用刚启动，网络请求还没有足够时间完成的时候可以展现一些数据给用户。当缓存占用了太多空间的时候，LeanStorage 会自动清空缓存。

默认情况下的查询不会使用缓存，除非你调用接口明确设置启用。例如，尝试从网络请求，如果网络不可用则从缓存数据中获取，可以这样设置：

```objc
AVQuery *query = [AVQuery queryWithClassName:@"Post"];
query.cachePolicy = kAVCachePolicyNetworkElseCache;

// 设置缓存有效期
query.maxCacheAge = 24*3600;

[query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
if (!error) {
    // 成功找到结果，先找网络再访问磁盘
} else {
    // 无法访问网络，本次查询结果未做缓存
}
}];
```

#### 缓存策略

为了满足多变的需求，SDK 默认提供了以下几种缓存策略：

策略枚举 | 含义及解释
--- | ---
`kAVCachePolicyIgnoreCache`| **（默认缓存策略）**查询行为不从缓存加载，也不会将结果保存到缓存中。
`kAVCachePolicyCacheOnly` | 查询行为忽略网络状况，只从缓存加载。如果没有缓存结果，该策略会产生 `AVError`。
`kAVCachePolicyCacheElseNetwork` | 查询行为首先尝试从缓存加载，若加载失败，则通过网络加载结果。如果缓存和网络获取行为均为失败，则产生 `AVError`。
`kAVCachePolicyNetworkElseCache` | 查询行为先尝试从网络加载，若加载失败，则从缓存加载结果。如果缓存和网络获取行为均为失败，则产生 `AVError`。
`kAVCachePolicyCacheThenNetwork` | 查询先从缓存加载，然后从网络加载。在这种情况下，回调函数会被调用两次，第一次是缓存中的结果，然后是从网络获取的结果。因为它会在不同的时间返回两个结果，所以该策略不能与 `findObjects` 同时使用。

#### 缓存相关的操作

- 检查是否存在缓存查询结果：

  ```objc
  BOOL isInCache = [query hasCachedResult];
  ```

- 删除某一查询的任何缓存结果：

  ```objc
  [query clearCachedResult];
  ```

- 删除查询的所有缓存结果：

  ```objc
  [AVQuery clearAllCachedResults];
  ```

- 设定缓存结果的最长时限：

  ```objc
  query.maxCacheAge = 60 * 60 * 24; // 一天的总秒数
  ```

查询缓存也适用于 `AVQuery` 的辅助方法，包括 `getFirstObject` 和 `getObjectInBackground`。
{% endif %}

### 查询性能优化

影响查询性能的因素很多。特别是当查询结果的数量超过 10 万，查询性能可能会显著下降或出现瓶颈。以下列举一些容易降低性能的查询方式，开发者可以据此进行有针对性的调整和优化，或尽量避免使用。

- 不等于和不包含查询（无法使用索引）
- 通配符在前面的字符串查询（无法使用索引）
- 有条件的 `count`（需要扫描所有数据）
- `skip` 跳过较多的行数（相当于需要先查出被跳过的那些行）
- 无索引的排序（另外除非复合索引同时覆盖了查询和排序，否则只有其中一个能使用索引）
- 无索引的查询（另外除非复合索引同时覆盖了所有条件，否则未覆盖到的条件无法使用索引，如果未覆盖的条件区分度较低将会扫描较多的数据）

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" or platform_name === "Swift" %}
## LiveQuery

LiveQuery 衍生于 [`{{ baseQueryClassName }}`](#查询)，并为其带来了更强大的功能。它可以让你无需编写复杂的逻辑便可在客户端之间同步数据，这对于有实时数据同步需求的应用来说很有帮助。

设想你正在开发一个多人协作同时编辑一份文档的应用，单纯地使用 `{{ baseQueryClassName }}` 并不是最好的做法，因为它只具备主动拉取的功能，而应用并不知道什么时候该去拉取。

想要解决这个问题，就要用到 LiveQuery 了。借助 LiveQuery，你可以订阅所有需要保持同步的 `{{ baseQueryClassName }}`。订阅成功后，一旦有符合 `{{ baseQueryClassName }}` 的 `{{ baseObjectName }}` 发生变化，云端就会主动、实时地将信息通知到客户端。

LiveQuery 使用 WebSocket 在客户端和云端之间建立连接。WebSocket 的处理会比较复杂，而我们将其封装成了一个简单的 API 供你直接使用，无需关注背后的原理。

### 启用 LiveQuery

进入 [控制台 > 存储 > 设置](/dashboard/storage.html?appid={{appid}}#/storage/conf)，在 **其他** 里面勾选 **启用 LiveQuery**{% if platform_name === "Objective-C" %}，然后将下面的 pod 添加到项目根目录下的 `Podfile` 即可：{% endif %}{% if platform_name === "Swift" %}，然后导入 LeanCloud Swift SDK：{% endif %}{% if platform_name === "JavaScript" %}，然后将下面的 npm 模块添加到项目中即可：{% endif %}{% if platform_name === "Android / Java" %}即可。确保即时通信模块已被添加到 `AndroidManifest.xml`：{% endif %}

{% if platform_name === "Objective-C" %}
```ruby
pod 'AVOSCloudLiveQuery'
```

可以在 [SDK 安装与初始化](#SDK-安装与初始化) 中找到完整设置方法。
{% endif %}
{% if platform_name === "Swift" %}
```swift
import LeanCloud
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 无需加载 leancloud-storage
var AV = require('leancloud-storage/live-query');
```

或者使用 `<script>` 标签：

```html
<!-- 无需加载 av-min.js -->
<script src="//cdn.jsdelivr.net/npm/leancloud-storage@{{jssdkversion}}/dist/av-live-query-min.js"></script>
```

可以在 [SDK 安装与初始化](#SDK-安装与初始化) 中找到完整设置方法。
{% endif %}
{% if platform_name === "Android / Java" %}
```xml
<service android:name="cn.leancloud.push.PushService"/>
<receiver android:name="cn.leancloud.push.AVBroadcastReceiver">
  <intent-filter>
    <action android:name="android.intent.action.BOOT_COMPLETED"/>
    <action android:name="android.intent.action.USER_PRESENT"/>
    <action android:name="android.net.conn.CONNECTIVITY_CHANGE" />
  </intent-filter>
</receiver>
```

可以在 [SDK 安装与初始化](#SDK-安装与初始化) 中找到完整设置方法。
{% endif %}

### Demo

下面是在使用了 LiveQuery 的网页应用和手机应用中分别操作，数据保持同步的效果：

<div style="border:2px solid #ccc; margin-bottom:1em;">
  <video src="https://lc-lhzo7z96.cn-n1.lcfile.com/1496988080458" controls autoplay muted preload="auto" width="100%" height="100%" >
    HTML5 Video is required for this demo, which your browser doesn't support.
  </video>
</div>

使用我们的「LeanTodo」微信小程序和网页应用，可以实际体验以上视频所演示的效果，步骤如下：

1. 微信扫码，添加小程序「LeanTodo」；<br/>
   <img src="images/leantodo-weapp-qr.png" width="150" height="150"> 
2. 进入小程序，点击首页左下角 **设置** > **账户设置**，输入便于记忆的用户名和密码；
3. 使用浏览器访问 <https://leancloud.github.io/leantodo-vue/>，输入刚刚在小程序中更新好的账户信息，点击 **Login**；
4. 随意添加更改数据，查看两端的同步状态。

{% call docs.noteWrap() %}
注意按以上顺序操作。在网页应用中使用 **Signup** 注册的账户无法与小程序创建的账户相关联，所以如果颠倒以上操作顺序，则无法观测到数据同步效果。
{% endcall %}

[LiveQuery 公开课](http://www.bilibili.com/video/av11291992/) 涵盖了许多开发者关心的问题和解答。

### 构建订阅

首先创建一个普通的 `{{ baseQueryClassName }}` 对象，添加查询条件（如有），然后进行订阅操作：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
self.liveQuery = [[AVLiveQuery alloc] initWithQuery:query];
self.liveQuery.delegate = self;
[self.liveQuery subscribeWithCallback:^(BOOL succeeded, NSError * _Nonnull error) {
    // 订阅成功
}];
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    let query = LCQuery(className: "Todo")
    self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in })
    self.liveQuery.subscribe { (result) in
        switch result {
        case .success:
            break
        case .failure(error: let error):
            print(error)
        }
    }
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.subscribe().then(function (liveQuery) {
  // 订阅成功
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
AVLiveQuery liveQuery = AVLiveQuery.initWithQuery(query);
liveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {
    @Override
    public void done(AVException e) {
        if (e == null) {
            // 订阅成功
        }
    }
});
```
{% endif %}

{% call docs.noteWrap() %}
LiveQuery 不支持内嵌查询，也不支持返回指定属性。
{% endcall %}

订阅成功后，就可以接收到和 `{{ baseObjectName }}` 相关的更新了。假如在另一个客户端上创建了一个 `Todo` 对象，对象的 `title` 设为 `更新作品集`，那么下面的代码可以获取到这个新的 `Todo`：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
self.liveQuery = [[AVLiveQuery alloc] initWithQuery:query];
self.liveQuery.delegate = self;
[self.liveQuery subscribeWithCallback:^(BOOL succeeded, NSError * _Nonnull error) {
    // 订阅成功
}];
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidCreate:(id)object {
    if (liveQuery == self.liveQuery) {
        NSLog(@"%@", object[@"title"]); // 更新作品集
    }
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    let query = LCQuery(className: "Todo")
    self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
        switch event {
        case .create(object: let object):
            print(object["title"] as Any) // 更新作品集
        default:
            break
        }
    })
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
query.subscribe().then(function (liveQuery) {
  liveQuery.on('create', function (newTodo) {
    console.log(newTodo.get('title')); // 更新作品集
  });
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
AVLiveQuery liveQuery = AVLiveQuery.initWithQuery(query);
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectCreated(AVObject newTodo) {
        System.out.println(newTodo.getString("title")); // 更新作品集
    }
});
liveQuery.subscribeInBackground(new AVLiveQuerySubscribeCallback() {
    @Override
    public void done(AVException e) {
        if (e == null) {
            // 订阅成功
        }
    }
});
```
{% endif %}

此时如果有人把 `Todo` 的 `content` 改为 `把我最近画的插画放上去`，那么下面的代码可以获取到本次更新：

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidUpdate:(id)updatedTodo updatedKeys:(NSArray<NSString *> *)updatedKeys {
    NSLog(@"%@", updatedTodo[@"content"]); // 把我最近画的插画放上去
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
do {
    let query = LCQuery(className: "Todo")
    self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
        switch event {
        case let .update(object: object, updatedKeys: updatedKeys):
            if let key = updatedKeys.first {
                print(object[key] as Any) // 把我最近画的插画放上去
            }
        default:
            break
        }
    })
} catch {
    print(error)
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('update', function (updatedTodo, updatedKeys) {
  console.log(updatedTodo.get('content')); // 把我最近画的插画放上去
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectUpdated(AVObject updatedTodo, List<String> updatedKeys) {
        System.out.println(updatedTodo.getString("content")); // 把我最近画的插画放上去
    }
});
```
{% endif %}

### 事件处理

订阅成功后，可以选择监听如下几种数据变化：

- `create`
- `update`
- `enter`
- `leave`
- `delete`
- `login`

#### `create` 事件

当有新的满足 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 被创建时，`create` 事件会被触发。下面的 `object` 就是新建的 `{{ baseObjectName }}`：

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidCreate:(id)object {
    if (liveQuery == self.liveQuery) {
        NSLog(@"对象被创建。");
    }
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case .create(object: let object):
        print("对象被创建。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('create', function (object) {
  console.log('对象被创建。');
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectCreated(AVObject object) {
        System.out.println("对象被创建。");
    }
});
```
{% endif %}

#### `update` 事件

当有满足 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 被更新时，`update` 事件会被触发。下面的 `object` 就是有更新的 `{{ baseObjectName }}`：

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidUpdate:(id)object updatedKeys:(NSArray<NSString *> *)updatedKeys {
    if (liveQuery == self.liveQuery) {
        NSLog(@"对象被更新。");
    }
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case let .update(object: object, updatedKeys: updatedKeys):
        print("对象被更新。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('update', function (object, updatedKeys) {
  console.log('对象被更新。');
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectUpdated(AVObject object, List<String> updatedKeys) {
        System.out.println("对象被更新。");
    }
});
```
{% endif %}

#### `enter` 事件

当一个已存在的、原本不符合 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 发生更新，且更新后符合查询条件，`enter` 事件会被触发。下面的 `object` 就是进入 `{{ baseQueryClassName }}` 的 `{{ baseObjectName }}`，其内容为该对象最新的值：

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidEnter:(id)object updatedKeys:(nonnull NSArray<NSString *> *)updatedKeys {
    if (liveQuery == self.liveQuery) {
        NSLog(@"对象进入。");
    }
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case let .enter(object: object, updatedKeys: updatedKeys):
        print("对象进入。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('enter', function (object, updatedKeys) {
  console.log('对象进入。');
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectEnter(AVObject object, List<String> updatedKeys) {
        System.out.println("对象进入。");
    }
});
```
{% endif %}

{% call docs.noteWrap() %}
注意区分 `create` 和 `enter` 的不同行为。如果一个对象已经存在，在更新之前不符合查询条件，而在更新之后符合查询条件，那么 `enter` 事件会被触发。如果一个对象原本不存在，后来被构建了出来，那么 `create` 事件会被触发。
{% endcall %}

#### `leave` 事件

当一个已存在的、原本符合 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 发生更新，且更新后不符合查询条件，`leave` 事件会被触发。下面的 `object` 就是离开 `{{ baseQueryClassName }}` 的 `{{ baseObjectName }}`，其内容为该对象最新的值：

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidLeave:(id)object updatedKeys:(nonnull NSArray<NSString *> *)updatedKeys {
    if (liveQuery == self.liveQuery) {
        NSLog(@"对象离开。");
    }
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case let .leave(object: object, updatedKeys: updatedKeys):
        print("对象离开。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('leave', function (object, updatedKeys) {
  console.log('对象离开。');
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectLeave(AVObject object, List<String> updatedKeys) {
        System.out.println("对象离开。");
    }
});
```
{% endif %}

#### `delete` 事件

当一个已存在的、原本符合 `{{ baseQueryClassName }}` 查询条件的 `{{ baseObjectName }}` 被删除，`delete` 事件会被触发。下面的 `object` 就是被删除的 `{{ baseObjectName }}` 的 `objectId`：

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery objectDidDelete:(id)object {
    if (liveQuery == self.liveQuery) {
        NSLog(@"对象被删除。");
    }
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case .delete(object: let object):
        print("对象被删除。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('delete', function (object) {
  console.log('对象被删除。');
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onObjectDeleted(String object) {
        System.out.println("对象被删除。");
    }
});
```
{% endif %}

#### `login` 事件

当一个用户成功登录应用，`login` 事件会被触发。下面的 `user` 就是登录的 `{{ userObjectName }}`：

{% if platform_name === "Objective-C" %}
```objc
- (void)liveQuery:(AVLiveQuery *)liveQuery userDidLogin:(AVUser *)user {
    if (liveQuery == self.liveQuery) {
        NSLog(@"用户登录。");
    }
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
self.liveQuery = try LiveQuery(query: query, eventHandler: { (liveQuery, event) in
    switch event {
    case .login(user: let user):
        print("用户登录。")
    default:
        break
    }
})
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.on('login', function (user) {
  console.log('用户登录。');
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
liveQuery.setEventHandler(new AVLiveQueryEventHandler() {
    @Override
    public void onUserLogin(AVUser user) {
        System.out.println("用户登录。");
    }
});
```
{% endif %}

### 取消订阅

如果不再需要接收有关 `{{ baseQueryClassName }}` 的更新，可以取消订阅。

{% if platform_name === "Objective-C" %}
```objc
[liveQuery unsubscribeWithCallback:^(BOOL succeeded, NSError * _Nonnull error) {
    if (succeeded) {
        // 成功取消订阅
    } else {
        // 错误处理
    }
}];
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
self.liveQuery.unsubscribe { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
liveQuery.unsubscribe().then(function () {
  // 成功取消订阅
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
liveQuery.unsubscribeInBackground(new AVLiveQuerySubscribeCallback() {
    @Override
    public void done(AVException e) {
        if (e == null) {
            // 成功取消订阅
        }
    }
});
```
{% endif %}

### 断开连接

断开连接有几种情况：

1. 网络异常或者网络切换，非预期性断开。
2. 退出应用、关机或者打开飞行模式等，用户在应用外的操作导致断开。

如上几种情况开发者无需做额外的操作，只要切回应用，SDK 会自动重新订阅，数据变更会继续推送到客户端。

而另外一种极端情况——**当用户在移动端使用手机的进程管理工具，杀死了进程或者直接关闭了网页的情况下**，SDK 无法自动重新订阅，此时需要开发者根据实际情况实现重新订阅。

### LiveQuery 的注意事项

因为 LiveQuery 的实时性，很多用户会陷入一个误区，试着用 LiveQuery 来实现一个简单的聊天功能。我们不建议这样做，因为使用 LiveQuery 构建聊天服务会承担额外的存储成本，产生的费用会增加，后期维护的难度非常大（聊天记录、对话维护之类的代码会很混乱），并且 LeanCloud 已经提供了 [即时通讯](realtime_v2.html) 的服务。LiveQuery 的核心还是提供一个针对查询的推拉结合的用法，脱离设计初衷容易造成前端的模块混乱。
{% endif %}

## 文件

有时候应用需要存储尺寸较大或结构较为复杂的数据，这类数据不适合用 `{{ baseObjectName }}` 保存，此时文件对象 `{{ fileObjectName }}` 便成为了更好的选择。文件对象最常见的用途是保存图片，不过也可以用来保存文档、视频、音乐等其他二进制数据。

### 构建文件

{% if platform_name === "Objective-C" %}
可以通过字符串构建文件：

```objc
NSData *data = [@"LeanCloud" dataUsingEncoding:NSUTF8StringEncoding];
// resume.txt 是文件名
AVFile *file = [AVFile fileWithData:data name:@"resume.txt"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
可以通过 base64 编码的字符串构建文件：

```js
var data = { base64: 'TGVhbkNsb3Vk' };
// resume.txt 是文件名
var file = new AV.File('resume.txt', data);
```

还可以通过字节数组构建文件：

```js
var data = [0x4c, 0x65, 0x61, 0x6e, 0x43, 0x6c, 0x6f, 0x75, 0x64];
var file = new AV.File('resume.txt', data);
```
{% endif %}
{% if platform_name === "Python" %}
可以通过字符串构建文件：

```python
from StringIO import StringIO

data = StringIO('LeanCloud')
# resume.txt 是文件名
file = leancloud.File('resume.txt', data)
```

还可以用 `buffer` 构建文件：

```python
data = buffer('\x4c\x65\x61\x6e\x43\x6c\x6f\x75\x64')
file = leancloud.File('resume.txt', data)
```
{% endif %}
{% if platform_name === "PHP" %}
可以通过字符串构建文件：

```php
// resume.txt 是文件名
$file = File::createWithData("resume.txt", "LeanCloud");
```
{% endif %}
{% if platform_name === "Android / Java" %}
可以通过字符串构建文件：

```java
// resume.txt 是文件名
AVFile file = new AVFile("resume.txt", "LeanCloud".getBytes());
```
{% endif %}
{% if platform_name === "Swift" %}
可以通过字符串构建文件：

```swift
if let data = "LeanCloud".data(using: .utf8) {
    let file = LCFile(payload: .data(data: data))
}
```
{% endif %}

除此之外，还可以通过 URL 构建文件：

{% if platform_name === "Objective-C" %}
```objc
AVFile *file = [AVFile fileWithRemoteURL:[NSURL URLWithString:@"https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png"]];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var file = AV.File.withURL(
  'logo.png',
  'https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png'
);
```
{% endif %}
{% if platform_name === "Python" %}
```python
file = leancloud.File.create_with_url('logo.png', 'https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithUrl("logo.png", "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVFile file = new AVFile(
    "logo.png",
    "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png",
    new HashMap<String, Object>()
);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let url = URL(string: "https://leancloud.cn/assets/imgs/press/Logo%20-%20Blue%20Padding.a60eb2fa.png") {
    let file = LCFile(url: url)
}
```
{% endif %}

{% call docs.noteWrap() %}
通过 URL 构建文件时，SDK 并不会将原本的文件转储到云端，而是会将文件的物理地址存储为字符串，这样也就不会产生任何文件上传流量。使用其他方式构建的文件会被保存在云端。
{% endcall %}

{% if platform_name === "JavaScript" or platform_name === "Python" or platform_name === "PHP" or platform_name === "Android / Java" or platform_name === "Swift" %}
LeanCloud 会根据文件扩展名自动检测文件类型。如果需要的话，也可以手动指定 `Content-Type`（一般称为 MIME 类型）：
{% endif %}

{% if platform_name === "JavaScript" %}
```js
var file = new AV.File('resume.txt', data, 'application/json');
```
{% endif %}
{% if platform_name === "Python" %}
```python
file = leancloud.File('resume.txt', StringIO('{"company":"LeanCloud"}'), 'application/json')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithData("resume.txt", "{\"company\":\"LeanCloud\"}", "application/json");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
Map<String, Object> meta = new HashMap<String, Object>();
meta.put("mime_type", "application/json");
AVFile file = new AVFile("resume.txt", "LeanCloud".getBytes(), meta);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let data = "{\"company\":\"LeanCloud\"}".data(using: .utf8) {
    let file = LCFile(payload: .data(data: data))
    file.mimeType = "application/json"
}
```
{% endif %}

与前面提到的方式相比，一个更常见的文件构建方式是从本地路径上传{{ "。如果开发的是 web 应用，可以先在页面上放一个按钮：" if platform_name === "JavaScript" else "：" }}

{% if platform_name === "Objective-C" %}
```objc
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
NSString *documentsDirectory = [paths objectAtIndex:0];
NSString *imagePath = [documentsDirectory stringByAppendingPathComponent:@"avatar.jpg"];
NSError *error;
AVFile *file = [AVFile fileWithLocalPath:imagePath error:&error];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```html
<input type="file" id="avatar-upload" />
```

然后在一个点击事件处理函数中获取这个文件：

```js
var avatarUpload = document.getElementById('avatar-upload');
if (avatarUpload.files.length) {
  var localFile = avatarUpload.files[0];
  var file = new AV.File('avatar.jpg', localFile);
}
```
{% endif %}
{% if platform_name === "Python" %}
```python
with open('/tmp/avatar.jpg', 'rb') as f:
    file = leancloud.File('avatar.jpg', f)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithLocalFile("/tmp/avatar.jpg");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVFile file = AVFile.withAbsoluteLocalPath("avatar.jpg", "/tmp/avatar.jpg");
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
if let url = Bundle.main.url(forResource: "avatar", withExtension: "jpg") {
    let file = LCFile(payload: .fileURL(fileURL: url))
}
```
{% endif %}

这里上传的文件名字叫做 `avatar.jpg`。需要注意：

- 每个文件会被分配到一个独一无二的 `objectId`，所以在一个应用内是允许多个文件重名的。
- 文件必须有扩展名才能被云端正确地识别出类型。比如说要用 `{{ fileObjectName }}` 保存一个 PNG 格式的图像，那么扩展名应为 `.png`。
- 如果文件没有扩展名，且没有手动指定类型，那么 LeanCloud 将默认使用 `application/octet-stream`。

### 保存文件

将文件保存到云端后，便可获得一个永久指向该文件的 URL：

{% if platform_name === "Objective-C" %}
```objc
[file uploadWithCompletionHandler:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        NSLog(@"文件保存完成。objectId：%@", file.objectId);
    } else {
        // 保存失败，可能是文件无法被读取，或者上传过程中出现问题
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
file.save().then(function (file) {
  console.log('文件保存完成。objectId：' + file.id);
}, function (error) {
  // 保存失败，可能是文件无法被读取，或者上传过程中出现问题
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
file.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file->save();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
file.saveInBackground().subscribe(new Observer<AVFile>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVFile file) {
        System.out.println("文件保存完成。objectId：" + file.getObjectId());
    }
    public void onError(Throwable throwable) {
        // 保存失败，可能是文件无法被读取，或者上传过程中出现问题
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = file.save { result in
    switch result {
    case .success:
        print("文件保存完成。objectId：" + file.objectId)
    case .failure(error: let error):
        // 保存失败，可能是文件无法被读取，或者上传过程中出现问题
        print(error)
    }
}
```
{% endif %}

{% call docs.noteWrap() %}
文件上传后，可以在 `_File` class 中找到。已上传的文件无法再被修改。如果需要修改文件，只能重新上传修改过的文件并取得新的 `objectId` 和 URL。
{% endcall %}

已经保存到云端的文件可以关联到 `{{ baseObjectName }}`：

{% if platform_name === "Objective-C" %}
```objc
AVObject *todo = [AVObject objectWithClassName:@"Todo"];
[todo setObject:@"买蛋糕" forKey:@"title"];
// attachments 是一个 Array 属性
[todo addObject:file forKey:@"attachments"];
[todo saveInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var Todo = AV.Object.extend('Todo');
var todo = new Todo();
todo.set('title', '买蛋糕');
// attachments 是一个 Array 属性
todo.add('attachments', file);
todo.save();
```
{% endif %}
{% if platform_name === "Python" %}
```python
Todo = leancloud.Object.extend('Todo')
todo = Todo()
todo.set('title', '买蛋糕')
# attachments 是一个 Array 属性
todo.add('attachments', file)
todo.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo = new LeanObject("Todo");
$todo->set("title", "买蛋糕");
// attachments 是一个 Array 属性
$todo->addIn("attachments", $file);
$todo->save();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject todo = new AVObject("Todo");
todo.put("title", "买蛋糕");
// attachments 是一个 Array 属性
todo.add("attachments", file);
todo.save();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let todo = LCObject(className: "Todo")
todo.set("title", value: "买蛋糕")
// attachments 是一个 Array 属性
todo.append("attachments", element: file)
todo.save()
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" %}
注意，如果文件被保存到了 `{{ baseObjectName }}` 的一个数组属性中，那么在查询 `{{ baseObjectName }}` 时如果需要包含文件，则要用到 `{{ baseQueryClassName }}` 的 `{% if platform_name === "Objective-C" %}includeKey{% endif %}{% if platform_name === "JavaScript" %}include{% endif %}{% if platform_name === "Android / Java"%}include{% endif %}` 方法。比如说，在获取所有标题为 `买蛋糕` 的 todo 的同时获取附件中的文件：
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
// 获取同一标题且包含附件的 todo
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
[query whereKey:@"title" equalTo:@"买蛋糕"];
[query whereKeyExists:@"attachments"];

// 同时获取附件中的文件
[query includeKey:@"attachments"];

[query findObjectsInBackgroundWithBlock:^(NSArray * _Nullable todos, NSError * _Nullable error) {
    for (AVObject *todo in todos) {
        // 获取每个 todo 的 attachments 数组
        // {# TODO #}
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 获取同一标题且包含附件的 todo
var query = new AV.Query('Todo');
query.equalTo('title', '买蛋糕');
query.exists('attachments');

// 同时获取附件中的文件
query.include('attachments');

query.find().then(function (todos) {
  todos.forEach(function (todo) {
    // 获取每个 todo 的 attachments 数组
    var attachments = todo.get('attachments');
    attachments.forEach(function (attachment) {
      // 每个附件都是一个 AV.File 实例
      console.log('附件 URL：', attachment.get('url'));
    });
  });
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 获取同一标题且包含附件的 todo
AVQuery<AVObject> query = new AVQuery<>("Todo");
query.whereEqualTo("title", "买蛋糕");
query.whereExists("attachments");

// 同时获取附件中的文件
query.include("attachments");

query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> todos) {
        for (AVObject todo : todos) {
            // 获取每个 todo 的 attachments 数组
            // {# TODO #}
        }
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" or platform_name === "Swift" %}
### 上传进度监听

上传过程中可以实时向用户展示进度：
{% endif %}

{% if platform_name === "Objective-C" %}
```objc
[file uploadWithProgress:^(NSInteger percent) {
    // percent 是一个 0 到 100 之间的整数，表示上传进度
} completionHandler:^(BOOL succeeded, NSError *error) {
    // 保存后的操作
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
file.save({
  onprogress: function (progress) {
    console.log(progress);
    // {
    //   loaded:  1024,
    //   total:   2048,
    //   percent: 50
    // }
  }
}).then(function (file) {
  // 保存后的操作
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
Observable<AVFile> result = file.saveInBackground(new ProgressCallback() {
    @Override
    public void done(Integer percent) {
        // percent 是一个 0 到 100 之间的整数，表示上传进度
    }
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = file.save(progress: { (progress) in
    print(progress)
}) { (result) in
    switch result {
    case .success:
        // 保存后的操作
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

### 文件元数据

上传文件时，可以用 `metaData` 添加额外的属性。文件一旦保存，`metaData` 便不可再修改。

{% if platform_name === "Objective-C" %}
```objc
// 设置元数据
[file.metaData setObject:@"LeanCloud" forKey:@"author"];
[file uploadWithCompletionHandler:^(BOOL succeeded, NSError *error) {
    // 获取全部元数据
    NSDictionary *metadata = file.metaData;
    // 获取 author 属性
    NSString *author = metadata[@"author"];
    // 获取文件名
    NSString *fileName = file.name;
    // 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
    NSUInteger *size = file.size;
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 设置元数据
file.metaData('author', 'LeanCloud');
file.save().then(function (file) {
  // 获取全部元数据
  var metadata = file.metaData();
  // 获取 author 属性
  var author = file.metaData('author');
  // 获取文件名
  var fileName = file.get('name');
  // 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
  var size = file.size();
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 设置元数据
file.metadata['author'] = 'LeanCloud'
file.save()

# 获取全部元数据
metadata = file.metadata
# 获取 author 属性
author = metadata['author']
# 获取文件名
file_name = file.name
# 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
size = file.size
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 设置元数据
$file->setMeta("author", "LeanCloud");
$file->save();

// 获取全部元数据
$metadata = $file->getMeta();
// 获取 author 属性
$author = $file->getMeta("author");
// 获取文件名
$fileName = $file->getName();
// 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
$size = $file->getSize();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 设置元数据
file.addMetaData("author", "LeanCloud");
file.saveInBackground().subscribe(new Observer<AVFile>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVFile file) {
        // 获取 author 属性
        String author = (String) file.getMetaData("author");
        // 获取文件名
        String fileName = file.getName();
        // 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
        int size = file.getSize();
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// 设置元数据
file.metaData["author"] = "LeanCloud"
_ = file.save { result in
    switch result {
    case .success:
        // 获取 author 属性
        String? author = file.metaData["author"]
        // 获取文件名
        String? fileName = file.name
        // 获取大小（不适用于通过 base64 编码的字符串或者 URL 保存的文件）
        UInt64? size = file.metaData["size"]
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if platform_name === "Objective-C" %}
### 文件下载

客户端 SDK 接口可以下载文件并把它缓存起来，只要文件的 URL 不变，那么一次下载成功之后，就不会再重复下载，目的是为了减少客户端的流量。

{% if platform_name === "Objective-C" %}
```objc
[file downloadWithProgress:^(NSInteger number) {
    // 下载的进度数据，number 介于 0 和 100
} completionHandler:^(NSURL * _Nullable filePath, NSError * _Nullable error) {
    // filePath 是文件下载到本地的地址
}];
```

`filePath` 是一个相对路径，文件存储在缓存目录（使用缓存功能）或系统临时目录（不使用缓存功能）中。

请注意代码中 `下载进度` 数据的读取。
{% endif %}
{% endif %}

{% if node !== "qcloud" %}
{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Python" or platform_name === "PHP" or platform_name === "Android / Java" %}
### 图像缩略图

保存图像时，如果想在下载原图之前先得到缩略图，方法如下：

{% if platform_name === "Objective-C" %}
```objc
AVFile *file = [AVFile fileWithRemoteURL:[NSURL URLWithString:@"文件-url"]];
[file getThumbnail:YES width:100 height:100 withBlock:^(UIImage *image, NSError *error) {
    // 其他逻辑
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 获得宽度为 100 像素，高度 200 像素的缩略图
var url = file.thumbnailURL(100, 200);
```
{% endif %}
{% if platform_name === "Python" %}
```python
avatar = leancloud.File.create_without_data('5732df1c1ea4930060ba4642')
avatar.fetch()

thumbnail_url = avatar.get_thumbnail_url(width=100, height=100)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::createWithUrl("test.jpg", "文件-url");
$file->getThumbnailUrl(100, 100);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVFile file = new AVFile("test.jpg", "文件-url", new HashMap<String, Object>());
file.getThumbnailUrl(true, 100, 100);
```
{% endif %}

{% call docs.noteWrap() %}
图片最大不超过 **20 MB** 才可以获取缩略图。
{% endcall %}

{% call docs.alertWrap() %}
图片缩略图只支持华北节点的应用，华东和北美节点不支持。
{% endcall %}
{% endif %}
{% endif %}

{% if platform_name === "Objective-C" %}
### 清除缓存

AVFile 也提供了清除缓存的方法：

```objc
// 清除当前文件缓存
- (void)clearPersistentCache;

// 类方法, 清除所有缓存
+ (BOOL)clearAllPersistentCache;
```
{% endif %}

### 删除文件

下面的代码从云端删除一个文件：

{% if platform_name === "Objective-C" %}
```objc
AVFile *file = [AVFile getFileWithObjectId:@"552e0a27e4b0643b709e891e"];
[file deleteInBackground];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var file = AV.File.createWithoutData('552e0a27e4b0643b709e891e');
file.destroy();
```
{% endif %}
{% if platform_name === "Python" %}
```python
file = leancloud.File.create_without_data('552e0a27e4b0643b709e891e')
file.destroy()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$file = File::fetch("552e0a27e4b0643b709e891e");
$file->destroy();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject file = AVObject.createWithoutData("_File", "552e0a27e4b0643b709e891e");
file.delete()
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let file = LCObject(className: "_File", objectId: "552e0a27e4b0643b709e891e")
file.delete()
```
{% endif %}

{% call docs.alertWrap() %}
默认情况下，文件的删除权限是关闭的，需要进入 [控制台 > 存储 > 数据 > `_File`](/dashboard/data.html?appid={{appid}}#/_File)，选择 **其他** > **权限设置** > **`delete`** 来开启。
{% endcall %}

### 启用 HTTPS 域名

如果希望使用 HTTPS 域名来访问文件，需要进入 [控制台 > 存储 > 设置 > 自定义文件域名](/dashboard/storage.html?appid={{appid}}#/storage/conf)，勾选 **启用 HTTPS 域名**。HTTPS 文件流量无免费的使用额度，收费标准将在该选项开启时显示。

「启用 HTTPS 域名」会影响到 API 返回的文件地址是 HTTPS 还是 HTTP 类型的 URL。需要注意的是，即使没有启用这一选项，终端仍然可以选择使用 HTTPS URL 来访问文件，但由此会产生 HTTPS 流量扣费。

在启用文件 HTTPS 域名之后，之前已保存在 `_File` 表中的文件的 URL 会自动被转换为以 HTTPS 开头。如果取消 HTTPS 域名，已经改为 HTTPS 域名的文件不会变回到 HTTP。

LeanCloud 即时通讯组件也使用 `{{ fileObjectName }}` 来保存消息的图片、音频等文件，并且把文件的地址写入到了消息内容中。当文件 HTTPS 域名被开启后，之前历史消息中的文件地址不会像 `_File` 表那样被自动转换，而依然保持 HTTP。

{% if platform_name === "Objective-C" %}
#### iOS 9 适配

从 iOS 9 开始，Apple 默认屏蔽 HTTP 访问，只支持 HTTPS 访问。LeanCloud 除了 `AVFile` 的 `getData` 之外的 API 都支持通过 HTTPS 访问。

如果你仍然需要 HTTP 访问，例如即时通讯消息中仍然有使用 HTTP 域名的文件，你可以 **为项目配置访问策略来允许 HTTP 访问**，从而解决这个问题。方法如下：

选择项目的 `Info.plist`，右击选择 **Opened As** > **Source Code**，在 **plist** > **dict** 节点中加入以下文本：

```xml
<key>NSAppTransportSecurity</key>
<dict>
  <key>NSExceptionDomains</key>
  <dict>
    <key>clouddn.com</key>
    <dict>
      <key>NSIncludesSubdomains</key>
      <true/>
      <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>
      <true/>
    </dict>
  </dict>
</dict>
```

或者在 **Target** 的 **Info** 标签中修改配置：

![在「NSAppTransportSecurity > NSExceptionDomains > clouddn.com」下面分别添加「NSTemporaryExceptionAllowsInsecureHTTPLoads」和「NSIncludesSubdomains」两个 Boolean 字段并将它们的值设为 YES。](../images/ios_qiniu_http.png)

你也可以根据项目需要，允许所有的 HTTP 访问，更多可参考 [iOS 9 适配系列教程](https://github.com/ChenYilong/iOS9AdaptationTips)。
{% endif %}

### CDN 加速

{{ data.cdn(true, fileObjectName) }}

{% if platform_name === "JavaScript" %}
## Promise

每一个在 LeanCloud JavaScript SDK 中的异步方法都会返回一个 `Promise`，可以用于处理该异步方法的完成与异常。下面的示例代码在查询到一个 `AV.Object` 后对其进行更新：

```js
let query = new AV.Query('Todo');
query.equalTo('priority', 1);
// find 方法是一个异步方法，会返回一个 Promise，之后可以使用 then 方法
query.find().then(function (todos) {
  // 返回符合条件的对象组成的数组
  let todo = todos[0];
  todo.set('notes', '今天需要完成。');
  // save 方法也是一个异步方法，会返回一个 Promise，所以在此处，你可以直接 return 出去，后续操作就可以支持链式 Promise 调用
  return todo.save();
}).then(function () {
  // 这里是 save 方法返回的 Promise
  console.log('成功更新 todo。');
}).catch(function (error) {
  // catch 方法写在 Promise 链式的最后，可以捕捉到全部 error
  console.error(error);
});
```

### `then` 方法

每一个 `Promise` 都有一个叫 `then` 的方法，这个方法接受一对 callback。第一个 callback 在 `Promise` 被解决（`resolved`，也就是正常运行）的时候调用，第二个会在 `Promise` 被拒绝（`rejected`，也就是遇到错误）的时候调用：

```js
todo.save().then(function (todo) {
  console.log('成功更新 todo。');
}, function (error) {
  console.error(error);
});
```

其中第二个参数是可选的。

你还可以使用 `catch` 方法，将逻辑写成：

```js
todo.save().then(function (todo) {
  console.log('成功更新 todo。');
}).catch(function (error) {
  console.error(error);
});
```

### 将 `Promise` 组织在一起

Promise 比较神奇，可以代替多层嵌套方式来解决发送异步请求代码的调用顺序问题。如果一个 `Promise` 的回调会返回一个 `Promise`，那么第二个 `then` 里的 callback 在第一个 `then` 的 callback 没有解决前是不会解决的，也就是所谓 **Promise Chain**。

```js
// 将内容按章节顺序添加到页面上
let chapterIds = [
  '584e1c408e450a006c676162', // 第一章
  '584e1c43128fe10058b01cf5', // 第二章
  '581aff915bbb500059ca8d0b'  // 第三章
];

new AV.Query('Chapter').get(chapterIds[0]).then(function (chapterOne) {
  // 向页面添加内容
  addHtmlToPage(chapterOne.get('content'));
  // 返回新的 Promise
  return new AV.Query('Chapter').get(chapterIds[1]);
}).then(function (chapterTwo) {
  addHtmlToPage(chapterTwo.get('content'));
  return new AV.Query('Chapter').get(chapterIds[2]);
}).then(function (chapterThree) {
  addHtmlToPage(chapterThree.get('content'));
  // 完成
});
```

### 错误处理

如果任意一个在链中的 `Promise` 抛出一个异常的话，所有接下来可能成功的 callback 都会被跳过直到遇到一个处理错误的 callback。

通常来说，在正常情况的回调函数链的末尾，加一个错误处理的回调函数，是一种很常见的做法。

利用 `catch` 方法可以将上述代码改写为：

```js
new AV.Query('Chapter').get(chapterIds[0]).then(function (chapterOne) {
  addHtmlToPage(chapterOne.get('content'));
  // 强制失败
  throw new Error('出错啦');
  return new AV.Query('Chapter').get(chapterIds[1]);
}).then(function (chapterTwo) {
  // 这里的代码将被忽略
  addHtmlToPage(chapterTwo.get('content'));
  return new AV.Query('Chapter').get(chapterIds[2]);
}).then(function (chapterThree) {
  // 这里的代码将被忽略
  addHtmlToPage(chapterThree.get('content'));
}).catch(function (error) {
  // 这个错误处理函数将被调用，错误信息是 '出错啦'
  console.error(error.message);
});
```

### `async` 和 `await`

`async` 和 `await` 能让你以更接近同步代码的方式使用 Promise：

```js
async function example() {
  try {
    let query = new AV.Query('Todo');
    query.equalTo('priority', 1);
    let todos = await query.find();
    let todo = todos[0];
    todo.set('notes', '今天需要完成。');
    return await todo.save();
  } catch (error) {
    console.error(error);
  }
}
```

如果你想更深入地了解和学习 Promise，包括如何对并行的异步操作进行控制，我们推荐阅读 [JavaScript Promise迷你书（中文版）](http://liubin.github.io/promises-book/)这本书。
{% endif %}

## GeoPoint

LeanCloud 允许你通过将 `{{ geoPointObjectName }}` 关联到 `{{ baseObjectName }}` 的方式存储折射真实世界地理位置的经纬坐标，这样做可以让你查询包含一个点附近的坐标的对象。常见的使用场景有「查找附近的用户」和「查找附近的地点」。

要构建一个包含地理位置的对象，首先要构建一个地理位置。下面的代码构建了一个 `{{geoPointObjectName}}` 并将其纬度（`latitude`）设为 `39.9`，经度（`longitude`）设为 `116.4`：

{% if platform_name === "Objective-C" %}
```objc
AVGeoPoint *point = [AVGeoPoint geoPointWithLatitude:39.9 longitude:116.4];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var point = new AV.GeoPoint(39.9, 116.4);

// 其他构建 AV.GeoPoint 的方式
var point = new AV.GeoPoint([39.9, 116.4]);
var point = new AV.GeoPoint({ latitude: 39.9, longitude: 116.4 });
```
{% endif %}
{% if platform_name === "Python" %}
```python
point = leancloud.GeoPoint(39.9, 116.4)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$point = new GeoPoint(39.9, 116.4);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVGeoPoint point = new AVGeoPoint(39.9, 116.4);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let point = LCGeoPoint(latitude: 39.9, longitude: 116.4)
```
{% endif %}

现在可以将这个地理位置存储为一个对象的属性：

{% if platform_name === "Objective-C" %}
```objc
[todo setObject:point forKey:@"location"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
todo.set('location', point);
```
{% endif %}
{% if platform_name === "Python" %}
```python
todo.set('location', point)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$todo->set("location", $point);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
todo.put("location", point);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
try todo.set("location", value: point)
```
{% endif %}

### 地理位置查询

给定一些含有地理位置的对象，可以从中找出离某一点最近的几个，或者处于某一范围内的几个。要执行这样的查询，可以向普通的 `{{ baseQueryClassName }}` 添加 `{% if platform_name === "Objective-C" %}nearGeoPoint{% endif %}{% if platform_name === "JavaScript" %}near{% endif %}{% if platform_name === "Python" %}near{% endif %}{% if platform_name === "PHP" %}near{% endif %}{% if platform_name === "Android / Java" %}whereNear{% endif %}{% if platform_name === "Swift" %}.locatedNear{% endif %}` 条件。下面的代码查找 `location` 属性值离某一点最近的 `Todo` 对象：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
AVGeoPoint *point = [AVGeoPoint geoPointWithLatitude:39.9 longitude:116.4];
[query whereKey:@"location" nearGeoPoint:point];

// 限制为 10 条结果
query.limit = 10;
[query findObjectsInBackgroundWithBlock:^(NSArray *todos, NSError *error) {
    // todos 是包含满足条件的 Todo 对象的数组
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
var point = new AV.GeoPoint(39.9, 116.4);
query.near('location', point);

// 限制为 10 条结果
query.limit(10);
query.find().then(function (todos) {
  // todos 是包含满足条件的 Todo 对象的数组
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('Todo')
point = leancloud.GeoPoint(39.9, 116.4)
query.near('location', point)

# 限制为 10 条结果
query.limit(10)
todo_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$point = new GeoPoint(39.9, 116.4);
$query->near("location", $point);

// 限制为 10 条结果
$query->limit(10);
$todos = $query->find();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
AVGeoPoint point = new AVGeoPoint(39.9, 116.4);
query.whereNear("location", point);

// 限制为 10 条结果
query.limit(10);
query.findInBackground().subscribe(new Observer<List<AVObject>>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(List<AVObject> todos) {
        // todos 是包含满足条件的 Todo 对象的数组
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
let point = LCGeoPoint(latitude: 39.9, longitude: 116.4)
query.whereKey("location", .locatedNear(point))

// 限制为 10 条结果
query.limit = 10
_ = query.find { result in
    switch result {
    case .success(objects: let todos):
        // todos 是包含满足条件的 Todo 对象的数组
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% call docs.noteWrap() %}
像 `{% if platform_name === "Objective-C" %}orderByAscending{% endif %}{% if platform_name === "JavaScript" %}ascending{% endif %}{% if platform_name === "Python" %}ascending{% endif %}{% if platform_name === "PHP" %}ascend{% endif %}{% if platform_name === "Android / Java" %}orderByAscending{% endif %}{% if platform_name === "Swift" %}.ascending{% endif %}` 和 `{% if platform_name === "Objective-C" %}orderByDescending{% endif %}{% if platform_name === "JavaScript" %}descending{% endif %}{% if platform_name === "Python" %}descending{% endif %}{% if platform_name === "PHP" %}descend{% endif %}{% if platform_name === "Android / Java" %}orderByDescending{% endif %}{% if platform_name === "Swift" %}.descending{% endif %}` 这样额外的排序条件会获得比默认的距离排序更高的优先级。
{% endcall %}

若要限制结果和给定地点之间的距离，可以参考 API 文档中的 {% if platform_name === "Objective-C" %}`withinKilometers`、`withinMiles` 和 `withinRadians`{% endif %}{% if platform_name === "JavaScript" %}`withinKilometers`、`withinMiles` 和 `withinRadians`{% endif %}{% if platform_name === "Python" %}`within_kilometers`、`within_miles` 和 `within_radians`{% endif %}{% if platform_name === "PHP" %}`withinKilometers`、`withinMiles` 和 `withinRadians`{% endif %}{% if platform_name === "Android / Java" %}`whereWithinKilometers`、`whereWithinMiles` 和 `whereWithinRadians`{% endif %}{% if platform_name === "Swift" %}`.locatedNear` 的 `from` 和 `to` 参数{% endif %}。

若要查询在某一矩形范围内的对象，可以用 {% if platform_name === "Objective-C" %}`withinGeoBoxFromSouthwest` 和 `toNortheast`{% endif %}{% if platform_name === "JavaScript" %}`withinGeoBox`{% endif %}{% if platform_name === "Python" %}`within_geo_box`{% endif %}{% if platform_name === "PHP" %}`withinBox`{% endif %}{% if platform_name === "Android / Java" %}`whereWithinGeoBox`{% endif %}{% if platform_name === "Swift" %}`.locatedWithin`{% endif %}：

<img width="300" height="200" src="images/geopoint-withingeobox.svg" />

{% if platform_name === "Objective-C" %}
```objc
AVQuery *query = [AVQuery queryWithClassName:@"Todo"];
AVGeoPoint *southwest = [AVGeoPoint geoPointWithLatitude:30 longitude:115];
AVGeoPoint *northeast = [AVGeoPoint geoPointWithLatitude:40 longitude:118];
[query whereKey:@"location" withinGeoBoxFromSouthwest:southwest toNortheast:northeast];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var query = new AV.Query('Todo');
var southwest = new AV.GeoPoint(30, 115);
var northeast = new AV.GeoPoint(40, 118);
query.withinGeoBox('location', southwest, northeast);
```
{% endif %}
{% if platform_name === "Python" %}
```python
query = leancloud.Query('Todo')
southwest = leancloud.GeoPoint(30, 115)
northeast = leancloud.GeoPoint(40, 118)
query.within_geo_box('location', southwest, northeast)
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$query = new Query("Todo");
$southwest = new GeoPoint(30, 115);
$northeast = new GeoPoint(40, 118);
$query->withinBox("location", $southwest, $northeast);
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVObject> query = new AVQuery<>("Todo");
AVGeoPoint southwest = new AVGeoPoint(30, 115);
AVGeoPoint northeast = new AVGeoPoint(40, 118);
query.whereWithinGeoBox("location", southwest, northeast);
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let query = LCQuery(className: "Todo")
let southwest = LCGeoPoint(latitude: 30, longitude: 115)
let northeast = LCGeoPoint(latitude: 40, longitude: 118)
query.whereKey("location", .locatedWithin(southwest: southwest, northeast: northeast))
```
{% endif %}

### GeoPoint 的注意事项

使用地理位置需要注意以下方面：

- 每个 `{{ baseObjectName }}` 数据对象中只能有一个 `{{ geoPointObjectName }}` 对象的属性。
- 地理位置的点不能超过规定的范围。纬度的范围应该是在 `-90.0` 到 `90.0` 之间，经度的范围应该是在 `-180.0` 到 `180.0` 之间。如果添加的经纬度超出了以上范围，将导致程序错误。
{# - Using the `near` constraint will also limit results to within 100 miles. #}
{% if platform_name === "Objective-C" %}
- iOS 8.0 之后，使用定位服务之前，需要调用 `[locationManager requestWhenInUseAuthorization]` 或 `[locationManager requestAlwaysAuthorization]` 来获取用户的「使用期授权」或「永久授权」，而这两个请求授权需要在 `info.plist` 里面对应添加 `NSLocationWhenInUseUsageDescription` 或 `NSLocationAlwaysUsageDescription` 的键值对，值为开启定位服务原因的描述。SDK 内部默认使用的是「使用期授权」。
{% endif %}

## 用户

用户系统几乎是每款应用都要加入的功能，我们为此专门提供了一个 `{{ userObjectName }}` 类来方便应用使用各项用户管理的功能。

`{{ userObjectName }}` 是 `{{ baseObjectName }}` 的子类，这意味着任何 `{{ baseObjectName }}` 提供的方法也适用于 `{{ userObjectName }}`，唯一的区别就是 `{{ userObjectName }}` 提供一些额外的用户管理相关的功能。每个应用都有一个专门的 `_User` class 用于存放所有的 `{{ userObjectName }}`。

### 用户的属性

`{{ userObjectName }}` 相比一个普通的 `{{ baseObjectName }}` 多出了以下属性：

- `username`：用户的用户名。
- `password`：用户的密码。
- `email`：用户的电子邮箱。
- `emailVerfied`：用户的电子邮箱是否已验证。
- `mobilePhoneNumber`：用户的手机号。
- `mobilePhoneVerfied`用户的手机号是否已验证。

在接下来对用户功能的介绍中我们会逐一了解到这些属性。

### 注册

用户第一次打开应用的时候，可以让用户注册一个账户。下面的代码展示了一个典型的使用用户名和密码注册的流程：

{% if platform_name === "Objective-C" %}
```objc
// 创建实例
AVUser *user = [AVUser user];

// 等同于 [user setObject:@"Tom" forKey:@"username"]
user.username = @"Tom";
user.password = @"cat!@#123";

// 可选
user.email = @"tom@leancloud.rocks";
user.phoneNumber = @"+8618200008888";

// 设置其他属性的方法跟 AVObject 一样
[user setObject:@"secret" forKey:@"gender"];

[user signUpInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // 注册成功
        NSLog(@"注册成功。objectId：%@", user.objectId);
    } else {
        // 注册失败（通常是因为用户名已被使用）
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// 创建实例
var user = new AV.User();

// 等同于 user.set('username', 'Tom')
user.setUsername('Tom');
user.setPassword('cat!@#123');

// 可选
user.setEmail('tom@leancloud.rocks');
user.setMobilePhoneNumber('+8618200008888');

// 设置其他属性的方法跟 AV.Object 一样
user.set('gender', 'secret');

user.signUp().then(function (user) {
  // 注册成功
  console.log('注册成功。objectId：' + user.id);
}, function (error) {
  // 注册失败（通常是因为用户名已被使用）
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
# 创建实例
user = leancloud.User()

# 等同于 user.set('username', 'Tom')
user.set_username('Tom')
user.set_password('cat!@#123')

# 可选
user.set_email('tom@leancloud.rocks')
user.set_mobile_phone_number('+8618200008888')

# 设置其他属性的方法跟 leancloud.Object 一样
user.set('gender', 'secret')

user.sign_up()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
// 创建实例
$user = new User();

// 等同于 $user->set("username", "Tom")
$user->setUsername("Tom");
$user->setPassword("cat!@#123");

// 可选
$user->setEmail("tom@leancloud.rocks");
$user->setMobilePhoneNumber("+8618200008888");

// 设置其他属性的方法跟 LeanObject 一样
$user->set("gender", "secret");

$user->signUp();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// 创建实例
AVUser user = new AVUser();

// 等同于 user.put("username", "Tom")
user.setUsername("Tom");
user.setPassword("cat!@#123");

// 可选
user.setEmail("tom@leancloud.rocks");
user.setMobilePhoneNumber("+8618200008888");

// 设置其他属性的方法跟 AVObject 一样
user.put("gender", "secret");

user.signUpInBackground().subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // 注册成功
        System.out.println("注册成功。objectId：" + user.getObjectId());
    }
    public void onError(Throwable throwable) {
        // 注册失败（通常是因为用户名已被使用）
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
// 创建实例
let user = LCUser()

// 等同于 user.set("username", value: "Tom")
user.username = LCString("Tom")
user.password = LCString("cat!@#123")

// 可选
user.set("email", value: "tom@leancloud.rocks")
user.set("mobilePhoneNumber", value: "+8618200008888")

// 设置其他属性的方法跟 LCObject 一样
user.set("gender", value: "secret")

assert(user.signUp().isSuccess)
```
{% endif %}

{% call docs.noteWrap() %}
新建 `{{ userObjectName }}` 的操作应使用 `{% if platform_name === "Objective-C" %}signUpInBackground{% endif %}{% if platform_name === "JavaScript" %}signUp{% endif %}{% if platform_name === "Python" %}sign_up{% endif %}{% if platform_name === "PHP" %}signUp{% endif %}{% if platform_name === "Android / Java" %}signUpInBackground{% endif %}{% if platform_name === "Swift" %}signUp{% endif %}` 而不是 `{% if platform_name === "Objective-C" %}saveInBackground{% endif %}{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Python" %}save{% endif %}{% if platform_name === "PHP" %}save{% endif %}{% if platform_name === "Android / Java" %}saveInBackground{% endif %}{% if platform_name === "Swift" %}save{% endif %}`，但以后的更新操作就可以用 `{% if platform_name === "Objective-C" %}saveInBackground{% endif %}{% if platform_name === "JavaScript" %}save{% endif %}{% if platform_name === "Python" %}save{% endif %}{% if platform_name === "PHP" %}save{% endif %}{% if platform_name === "Android / Java" %}saveInBackground{% endif %}{% if platform_name === "Swift" %}save{% endif %}` 了。
{% endcall %}

如果收到 `202` 错误码，意味着 `_User` 表里已经存在使用同一 `username` 的账号，此时应提示用户换一个用户名。除此之外，每个用户的 `email` 和 `mobilePhoneNumber` 也需要保持唯一性，否则会收到 `203` 或 `214` 错误。可以考虑在注册时把用户的 `username` 设为与 `email` 相同，这样用户可以直接 [用邮箱重置密码](#重置密码)。

{% call docs.noteWrap() %}
采用「用户名 + 密码」注册时需要注意：密码是以明文方式通过 HTTPS 加密传输给云端，云端会以密文存储密码（云端对密码的长度、复杂度不作限制），并且我们的加密算法是无法通过所谓「彩虹表撞库」获取的，这一点请开发者放心。换言之，用户的密码只可能用户本人知道，开发者不论是通过控制台还是 API 都是无法获取。另外我们需要强调 **在客户端，应用切勿再次对密码加密，这会导致 [重置密码](#重置密码) 等功能失效**。
{% endcall %}

{% if node !== "qcloud" %}
#### 手机号注册

对于移动应用来说，允许用户以手机号注册是个很常见的需求。实现该功能大致分两步，第一步是让用户提供手机号，点击「获取验证码」按钮后，该号码会收到一个六位数的验证码：

{% if platform_name === "Objective-C" %}
```objc
[AVOSCloud requestSmsCodeWithPhoneNumber:@"+8618200008888"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.Cloud.requestSmsCode('+8618200008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.cloudfunc.request_sms_code('+8618200008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
SMS::requestSmsCode("+8618200008888");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.requestLoginSmsCodeInBackground("+8618200008888").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCSMSClient.requestVerificationCode(mobilePhoneNumber: "+8618200008888") { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

用户填入验证码后，用下面的方法完成注册：

{% if platform_name === "Objective-C" %}
```objc
[AVUser signUpOrLoginWithMobilePhoneNumberInBackground:@"+8618200008888" smsCode:@"123456" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // 注册成功
        NSLog(@"注册成功。objectId：%@", user.objectId);
    } else {
        // 验证码不正确
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.signUpOrlogInWithMobilePhone('+8618200008888', '123456').then(function (user) {
  // 注册成功
  console.log('注册成功。objectId：' + user.id);
}, function (error) {
  // 验证码不正确
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.signup_or_login_with_mobile_phone('+8618200008888', '123456')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::signUpOrLoginByMobilePhone("+8618200008888", "123456");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.signUpOrLoginByMobilePhoneInBackground("+8618200008888", "123456").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // 注册成功
        System.out.println("注册成功。objectId：" + user.getObjectId());
    }
    public void onError(Throwable throwable) {
        // 验证码不正确
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCSMSClient.verifyMobilePhoneNumber("+8618200008888", verificationCode: "123456", completion: { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
})
```
{% endif %}

{% call docs.noteWrap() %}
`username` 将与 `mobilePhoneNumber` 相同，`password` 会由云端随机生成。
{% endcall %}

#### 手机号格式

`{{ userObjectName }}` 接受的手机号以 `+` 和国家代码开头，后面紧跟着剩余的部分。手机号中不应含有任何划线、空格等非数字字符。例如，`+19490008888` 是一个合法的美国或加拿大手机号（`1` 是国家代码），`+8618200008888` 是一个合法的中国手机号（`86` 是国家代码）。

请参阅短信 SMS 服务使用指南中的 [服务覆盖区域和价格](sms-guide.html#服务覆盖区域和价格) 以了解 LeanCloud 支持的国家和地区。
{% endif %}

### 登录

下面的代码用用户名和密码登录一个账户：

{% if platform_name === "Objective-C" %}
```objc
[AVUser logInWithUsernameInBackground:@"Tom" password:@"cat!@#123" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // 登录成功
    } else {
        // 登录失败（可能是密码错误）
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.logIn('Tom', 'cat!@#123').then(function (user) {
  // 登录成功
}, function (error) {
  // 登录失败（可能是密码错误）
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.login(username='Tom', password='cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logIn("Tom", "cat!@#123");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.logIn("Tom", "cat!@#123").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // 登录成功
    }
    public void onError(Throwable throwable) {
        // 登录失败（可能是密码错误）
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(username: "Tom", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

#### 邮箱登录

下面的代码用邮箱和密码登录一个账户：

{% if platform_name === "Objective-C" %}
```objc
[AVUser loginWithEmail:@"tom@leancloud.rocks" password:@"cat!@#123" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // 登录成功
    } else {
        // 登录失败（可能是密码错误）
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.loginWithEmail('tom@leancloud.rocks', 'cat!@#123').then(function (user) {
  // 登录成功
}, function (error) {
  // 登录失败（可能是密码错误）
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.login(email='tom@leancloud.rocks', password='cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logInWithEmail("tom@leancloud.rocks", "cat!@#123");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.loginByEmail("tom@leancloud.rocks", "cat!@#123").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // 登录成功
    }
    public void onError(Throwable throwable) {
        // 登录失败（可能是密码错误）
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(email: "tom@leancloud.rocks", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% if node !== "qcloud" %}
#### 手机号登录

如果应用允许用户以手机号注册，那么也可以让用户以手机号配合密码或短信验证码登录。下面的代码用手机号和密码登录一个账户：

{% if platform_name === "Objective-C" %}
```objc
[AVUser logInWithMobilePhoneNumberInBackground:@"+8618200008888" password:@"cat!@#123" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // 登录成功
    } else {
        // 登录失败（可能是密码错误）
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.logInWithMobilePhone('+8618200008888', 'cat!@#123').then(function (user) {
  // 登录成功
}, function (error) {
  // 登录失败（可能是密码错误）
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.login_with_mobile_phone('+8618200008888', 'cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logInWithMobilePhoneNumber("+8618200008888", "cat!@#123");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.loginByMobilePhoneNumber("+8618200008888", "cat!@#123").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // 登录成功
    }
    public void onError(Throwable throwable) {
        // 登录失败（可能是密码错误）
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(mobilePhoneNumber: "+8618200008888", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

{% call docs.noteWrap() %}
默认情况下，LeanCloud 允许所有关联了手机号的用户直接以手机号登录，无论手机号是否 [通过验证](#验证手机号)。为了让应用更加安全，你可以选择只允许验证过手机号的用户通过手机号登录。可以在 [控制台 > 存储 > 设置](/dashboard/storage.html?appid={{appid}}#/storage/conf) 里面开启该功能。
{% endcall %}

除此之外，还可以让用户通过短信验证码登录，适用于用户忘记密码且不愿重置密码的情况。和 [通过手机号注册](#手机号注册) 的步骤类似，首先让用户填写与账户关联的手机号码，然后在用户点击「获取验证码」后调用下面的方法：

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestLoginSmsCode:@"+8618200008888"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestLoginSmsCode('+8618200008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_login_sms_code('+8618200008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
SMS::requestSmsCode("+8618200008888");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.requestLoginSmsCodeInBackground("+8618200008888").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestLoginVerificationCode(mobilePhoneNumber: "+8618200008888") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

用户填写收到的验证码后，用下面的方法完成登录：

{% if platform_name === "Objective-C" %}
```objc
[AVUser logInWithMobilePhoneNumberInBackground:@"+8618200008888" smsCode:@"123456" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // 登录成功
    } else {
        // 验证码不正确
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.logInWithMobilePhoneSmsCode('+8618200008888', '123456').then(function (user) {
  // 登录成功
}, function (error) {
  // 验证码不正确
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.signup_or_login_with_mobile_phone('+8618200008888', '123456')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::signUpOrLoginByMobilePhone("+8618200008888", "123456");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.signUpOrLoginByMobilePhoneInBackground("+8618200008888", "123456").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // 登录成功
    }
    public void onError(Throwable throwable) {
        // 验证码不正确
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(mobilePhoneNumber: "+8618200008888", verificationCode: "123456") { result in
    switch result {
    case .success(object: let user):
        print(user)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

#### 测试手机号和固定验证码

在开发过程中，可能会因测试目的而需要频繁地用手机号注册登录，然而运营商的发送频率限制往往会导致测试过程耗费较多的时间。

为了解决这个问题，可以在 [控制台 > 消息 > 短信 > 设置](/dashboard/messaging.html?appid={{appid}}#/message/sms/conf) 里面设置一个测试手机号，而云端会为该号码生成一个固定验证码。以后进行登录操作时，只要使用的是这个号码，云端就会直接放行，无需经过运营商网络。

测试手机号还可用于将 iOS 应用提交到 App Store 进行审核的场景，因为审核人员可能因没有有效的手机号码而无法登录应用来进行评估审核。如果不提供一个测试手机号，应用有可能被拒绝。

可参阅 [短信 SMS 服务使用指南](sms-guide.html) 来了解更多有关短信发送和接收的限制。
{% endif %}

#### 单设备登录

某些场景下需要确保用户的账户在同一时间只在一台设备上登录，也就是说当用户在一台设备上登录后，其他设备上的会话全部失效。可以按照以下方案来实现：

1. 新建一个专门用于记录用户登录信息和当前设备信息的 class。
2. 每当用户在新设备上登录时，将该 class 中该用户对应的设备更新为该设备。
3. 在另一台设备上打开客户端时，检查该设备是否与云端保存的一致。若不一致，则将用户 [登出](#当前用户)。

#### 账户锁定

输入错误的密码或验证码会导致用户登录失败。如果在 15 分钟内，同一个用户登录失败的次数大于 6 次，该用户账户即被云端暂时锁定，此时云端会返回错误码 `{ "code": 1, "error": "You have exceeded the maximum number of login attempts, please try again later, or consider resetting your password." }`，开发者可在客户端进行必要提示。

锁定将在最后一次错误登录的 15 分钟之后由云端自动解除，开发者无法通过 SDK 或 REST API 进行干预。在锁定期间，即使用户输入了正确的验证信息也不允许登录。这个限制在 SDK 和云引擎中都有效。

### 验证邮箱

可以通过要求用户在登录或使用特定功能之前验证邮箱的方式防止恶意注册。默认情况下，当用户注册或变更邮箱后，`emailVerified` 会被设为 `false`。在应用的 [控制台 > 存储 > 设置](/dashboard/storage.html?appid={{appid}}#/storage/conf) 中，可以开启 **从客户端注册邮箱或者更新邮箱时，发送验证邮件** 选项，这样当用户注册或变更邮箱时，会收到一封含有验证链接的邮件。在同一设置页面还可找到阻止未验证邮箱的用户登录的选项。

如果用户忘记点击链接并且在未来某一时刻需要进行验证，可以用下面的代码发送一封新的邮件：

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestEmailVerify:@"tom@leancloud.rocks"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestEmailVerify('tom@leancloud.rocks');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_email_verify('tom@leancloud.rocks')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestEmailVerify("tom@leancloud.rocks");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.requestEmailVerifyInBackground("tom@leancloud.rocks").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestVerificationMail(email: "tom@leancloud.rocks") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

用户点击邮件内的链接后，`emailVerified` 会变为 `true`。如果用户的 `email` 属性为空，则该属性永远不会为 `true`。

{% if node !== "qcloud" %}
### 验证手机号

和 [验证邮箱](#验证邮箱) 类似，应用还可以要求用户在登录或使用特定功能之前验证手机号。默认情况下，当用户注册或变更手机号后，`mobilePhoneVerified` 会被设为 `false`。在应用的 [控制台 > 存储 > 设置](/dashboard/storage.html?appid={{appid}}#/storage/conf) 中，可以开启 **从客户端注册或更新手机号时，向注册手机号码发送验证短信** 选项，这样当用户注册或变更手机号时，会收到一条含有验证码的短信。在同一设置页面还可找到阻止未验证手机号的用户登录的选项。

可以随时用下面的代码发送一条新的验证码：

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestMobilePhoneVerify:@"+8618200008888"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestMobilePhoneVerify('+8618200008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_mobile_phone_verify('+8618200008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestMobilePhoneVerify("+8618200008888");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.requestMobilePhoneVerifyInBackground("+8618200008888").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestVerificationCode(mobilePhoneNumber: "+8618200008888") { result in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

用户填写验证码后，调用下面的方法来完成验证。`mobilePhoneVerified` 将变为 `true`：

{% if platform_name === "Objective-C" %}
```objc
[AVUser verifyMobilePhone:@"123456" block:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // mobilePhoneVerified 将变为 true
    } else {
        // 验证码不正确
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.verifyMobilePhone('123456').then(function () {
  // mobilePhoneVerified 将变为 true
}, function (error) {
  // 验证码不正确
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.verify_mobile_phone_number('123456')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::verifyMobilePhone("123456");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.verifyMobilePhoneInBackground("123456").subscribe(new Observer<AVNull>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVNull null) {
        // mobilePhoneVerified 将变为 true
    }
    public void onError(Throwable throwable) {
        // 验证码不正确
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.verifyMobilePhoneNumber(mobilePhoneNumber: "+8618200008888", verificationCode: "123456") { result in
    switch result {
    case .success:
        // mobilePhoneVerified 将变为 true
        break
    case .failure(error: let error):
        // 验证码不正确
        print(error)
    }
}
```
{% endif %}
{% endif %}

{# ### CAPTCHA Code

Using [CAPTCHA](https://en.wikipedia.org/wiki/CAPTCHA) is a common and effective practice to protest your application from spam and abuse. CAPTCHA offers more than just spam protection. It also helps  reduce fraud and associated costs by blocking bots that could trigger bulk SMS sending.   

LeanCloud CAPTCHA aims to keep bots or other automated software from engaging in abusive activities while letting your valid users pass through with ease.

LeanCloud offers CAPTCHA as a free service to make your app's more bot-proof. #}

{% if platform_name !== "Swift" %}

### 当前用户

用户登录后，SDK 会自动将会话信息存储到客户端，这样用户在下次打开客户端时无需再次登录。下面的代码检查是否有已经登录的用户：

{% if platform_name === "Objective-C" %}
```objc
AVUser *currentUser = [AVUser currentUser];
if (currentUser != nil) {
    // 跳到首页
} else {
    // 显示注册或登录页面
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var currentUser = AV.User.current();
if (currentUser) {
  // 跳到首页
} else {
  // 显示注册或登录页面
}
```
{% endif %}
{% if platform_name === "Python" %}
```python
current_user = leancloud.User.get_current()
if current_user is not None:
    # 跳到首页
    pass
else:
    # 显示注册或登录页面
    pass
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$currentUser = User::getCurrentUser();
if ($currentUser != null) {
    // 跳到首页
} else {
    // 显示注册或登录页面
}
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser currentUser = AVUser.getCurrentUser();
if (currentUser != null) {
    // 跳到首页
} else {
    // 显示注册或登录页面
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let currentUser = LCApplication.default.currentUser
```
{% endif %}

会话信息会长期有效，直到用户主动登出：

{% if platform_name === "Objective-C" %}
```objc
[AVUser logOut];

// currentUser 变为 nil
AVUser *currentUser = [AVUser currentUser];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.logOut();

// currentUser 变为 null
var currentUser = AV.User.current();
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.logout()

# current_user 变为 None
current_user = leancloud.User.get_current()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logOut();

// currentUser 变为 null
$currentUser = User::getCurrentUser();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.logOut();

// currentUser 变为 null
AVUser currentUser = AVUser.getCurrentUser();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
LCUser.logOut()

// currentUser 变为 nil
let currentUser = LCApplication.default.currentUser
```
{% endif %}

### 设置当前用户

用户登录后，云端会返回一个 **session token** 给客户端，它会由 SDK 缓存起来并用于日后同一 `{{ userObjectName }}` 的鉴权请求。session token 会被包含在每个客户端发起的 HTTP 请求的 header 里面，这样云端就知道是哪个 `{{ userObjectName }}` 发起的请求了。

以下是一些应用可能需要用到 session token 的场景：

- 应用根据以前缓存的 session token 登录（可以用 `{% if platform_name === "Objective-C" %}{# TODO #}{% endif %}{% if platform_name === "JavaScript" %}AV.User.current().getSessionToken(){% endif %}{% if platform_name === "Python" %}leancloud.User.get_current().get_session_token(){% endif %}{% if platform_name === "PHP" %}User::getCurrentSessionToken(){% endif %}{% if platform_name === "Android / Java" %}AVUser.getCurrentUser().getSessionToken(){% endif %}{% if platform_name === "Swift" %}LCApplication.default.currentUser?.sessionToken{% endif %}` 获取到当前用户的 session token）。
- 应用内的某个 WebView 需要知道当前登录的用户。
- 在服务端登录后，返回 session token 给客户端，客户端根据返回的 session token 登录。

下面的代码使用 session token 登录一个用户（云端会验证 session token 是否有效）：

{% if platform_name === "Objective-C" %}
```objc
[AVUser becomeWithSessionTokenInBackground:@"anmlwi96s381m6ca7o7266pzf" block:^(AVUser * _Nullable user, NSError * _Nullable error) {
    if (user != nil) {
        // 登录成功
    } else {
        // session token 无效
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.become('anmlwi96s381m6ca7o7266pzf').then(function (user) {
  // 登录成功
}, function (error) {
  // session token 无效
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.become('anmlwi96s381m6ca7o7266pzf')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::become("anmlwi96s381m6ca7o7266pzf");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.becomeWithSessionTokenInBackground("anmlwi96s381m6ca7o7266pzf").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // 登录成功
    }
    public void onError(Throwable throwable) {
        // session token 无效
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(sessionToken: "anmlwi96s381m6ca7o7266pzf") { (result) in
    switch result {
    case .success(object: let user):
        // 登录成功
        print(user)
    case .failure(error: let error):
        // session token 无效
        print(error)
    }
}
```
{% endif %}

{% call docs.alertWrap() %}
请避免在外部浏览器使用 URL 来传递 session token，以防范信息泄露风险。
{% endcall %}

{% call docs.noteWrap() %}
如果在 [控制台 > 存储 > 设置](/dashboard/storage.html?appid={{appid}}#/storage/conf) 中勾选了 **密码修改后，强制客户端重新登录**，那么当一个用户修改密码后，该用户的 session token 会被重置。此时需要让用户重新登录，否则会遇到 [`403 (Forbidden)`](error_code.html#_403) 错误。
{% endcall %}

下面的代码检查 session token 是否有效：

{% if platform_name === "Objective-C" %}
```objc
AVUser *currentUser = [AVUser currentUser];
NSString *token = currentUser.sessionToken;
[currentUser isAuthenticatedWithSessionToken:token callback:^(BOOL succeeded, NSError * _Nullable error) {
    if (succeeded) {
        // session token 有效
    } else {
        // session token 无效
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var currentUser = AV.User.current();
currentUser.isAuthenticated().then(function (authenticated) {
  if (authenticated) {
    // session token 有效
  } else {
    // session token 无效
  }
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
authenticated = leancloud.User.get_current().is_authenticated()
if authenticated:
    # session token 有效
    pass
else:
    # session token 无效
    pass
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$authenticated = User::isAuthenticated();
if ($authenticated) {
    // session token 有效
} else {
    // session token 无效
}
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
boolean authenticated = AVUser.getCurrentUser().isAuthenticated();
if (authenticated) {
    // session token 有效
} else {
    // session token 无效
}
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
{# TODO #}
```
{% endif %}

{% endif %}

### 重置密码

我们都知道，应用一旦加入账户密码系统，那么肯定会有用户忘记密码的情况发生。对于这种情况，我们为用户提供了多种重置密码的方法。

邮箱重置密码的流程如下：

1. 用户输入注册的电子邮箱，请求重置密码；
2. LeanCloud 向该邮箱发送一封包含重置密码的特殊链接的电子邮件；
3. 用户点击重置密码链接后，一个特殊的页面会打开，让他们输入新密码；
4. 用户的密码已被重置为新输入的密码。

首先让用户填写注册账户时使用的邮箱，然后调用下面的方法：

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestPasswordResetForEmailInBackground:@"tom@leancloud.rocks"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestPasswordReset('tom@leancloud.rocks');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_password_reset('tom@leancloud.rocks')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestPasswordReset("tom@leancloud.rocks");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.requestPasswordResetInBackground("tom@leancloud.rocks").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestPasswordReset(email: "tom@leancloud.rocks") { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

上面的代码会查询 `_User` 表中是否有对象的 `email` 属性与前面提供的邮箱匹配。如果有的话，则向该邮箱发送一封密码重置邮件。之前提到过，应用可以让 `username` 与 `email` 保持一致，也可以单独收集用户的邮箱并将其存为 `email`。

{% call docs.noteWrap() %}
密码重置邮件的内容可在应用的 [控制台 > 设置 > 邮件模版](/dashboard/app.html?appid={{appid}}#/email) 中自定义。更多关于自定义邮件模板和验证链接的内容，请参考 [自定义应用内用户重设密码和邮箱验证页面](https://leancloudblog.com/zi-ding-yi-ying-yong-nei-yong-hu-chong-she-mi-ma-he-you-xiang-yan-zheng-ye-mian/)。
{% endcall %}

{% if node !== "qcloud" %}
除此之外，还可以用手机号重置密码：

1. 用户输入注册的手机号，请求重置密码；
2. LeanCloud 向该号码发送一条包含验证码的短信；
3. 用户输入验证码和新密码。

下面的代码向用户发送含有验证码的短信：

{% if platform_name === "Objective-C" %}
```objc
[AVUser requestPasswordResetWithPhoneNumber:@"+8618200008888"];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.requestPasswordResetBySmsCode('+8618200008888');
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.request_password_reset_by_sms_code('+8618200008888')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::requestPasswordResetBySmsCode("+8618200008888");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.requestPasswordResetBySmsCodeInBackground("+8618200008888").blockingSubscribe();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.requestPasswordReset(mobilePhoneNumber: "+8618200008888") { (result) in
    switch result {
    case .success:
        break
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

上面的代码会查询 `_User` 表中是否有对象的 `mobilePhoneNumber` 属性与前面提供的手机号匹配。如果有的话，则向该号码发送验证码短信。

{% call docs.noteWrap() %}
可以在 [控制台 > 存储 > 设置](/dashboard/storage.html?appid={{appid}}#/storage/conf) 中设置只有在 `mobilePhoneVerified` 为 `true` 的情况下才能用手机号重置密码。
{% endcall %}

用户输入验证码和新密码后，用下面的代码完成密码重置：

{% if platform_name === "Objective-C" %}
```objc
[AVUser resetPasswordWithSmsCode:@"123456" newPassword:@"cat!@#123" block:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // 密码重置成功
    } else {
        // 验证码不正确
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.resetPasswordBySmsCode('123456', 'cat!@#123').then(function () {
  // 密码重置成功
}, function (error) {
  // 验证码不正确
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.reset_password_by_sms_code('123456', 'cat!@#123')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::resetPasswordBySmsCode("123456", "cat!@#123");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.resetPasswordBySmsCodeInBackground("123456", "cat!@#123").subscribe(new Observer<AVNull>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVNull null) {
        // 密码重置成功
    }
    public void onError(Throwable throwable) {
        // 验证码不正确
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.resetPassword(mobilePhoneNumber: "+8618200008888", verificationCode: "123456", newPassword: "cat!@#123") { result in
    switch result {
    case .success:
        // 密码重置成功
        break
    case .failure(error: let error):
        // 验证码不正确
        print(error)
    }
}
```
{% endif %}

{# > Note that the messaging in either of the above flows will reference your app by the name that you specified when you created this app on LeanCloud. #}
{% endif %}

### 用户的查询

可以直接构建一个针对 `_User` 的 `{{ baseQueryClassName }}` 来查询用户：

{% if platform_name === "Objective-C" %}
```objc
AVQuery *userQuery = [AVUser query];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var userQuery = new AV.Query('_User');
```
{% endif %}
{% if platform_name === "Python" %}
```python
user_query = leancloud.Query('_leancloud.User')
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$userQuery = new Query("_User");
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVQuery<AVUser> userQuery = AVUser.getQuery();
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let userQuery = LCQuery(className: "_User")
```
{% endif %}

为了安全起见，**新创建的应用的 `_User` 表默认关闭了 `find` 权限**，这样每位用户登录后只能查询到自己在 `_User` 表中的数据，无法查询其他用户的数据。如果需要让其查询其他用户的数据，建议单独创建一张表来保存这类数据，并开放这张表的 `find` 查询权限。除此之外，还可以在 [云引擎](leanengine_overview.html) 里封装用户查询相关的方法，这样就无需开放 `_User` 表的 `find` 权限。

可以参见 [用户对象的安全](#用户对象的安全) 来了解 `_User` 表的一些限制，还可以阅读 [数据和安全](data_security.html) 来了解更多 class 级权限设置的方法。

### 关联用户对象

关联 `{{ userObjectName }}` 的方法和 `{{ baseObjectName }}` 是一样的。下面的代码为一名作者保存了一本书，然后获取所有该作者写的书：

{% if platform_name === "Objective-C" %}
```objc
AVObject *book = [AVObject objectWithClassName:@"Book"];
AVUser *author = [AVUser currentUser];
[book setObject:@"我的第五本书" forKey:@"title"];
[book setObject:author forKey:@"author"];
[book saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    // 获取所有该作者写的书
    AVQuery *query = [AVQuery queryWithClassName:@"Book"];
    [query whereKey:@"author" equalTo:author];
    [query findObjectsInBackgroundWithBlock:^(NSArray *books, NSError *error) {
        // books 是包含同一作者所有 Book 对象的数组
    }];
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var Book = AV.Object.extend('Book');
var book = new Book();
var author = AV.User.current();
book.set('title', '我的第五本书');
book.set('author', author);
book.save().then(function (book) {
  // 获取所有该作者写的书
  var query = new AV.Query('Book');
  query.equalTo('author', author);
  query.find().then(function (books) {
    // books 是包含同一作者所有 Book 对象的数组
  });
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
Book = leancloud.Object.extend('Book')
book = Book()
author = leancloud.User.get_current()
book.set('title', '我的第五本书')
book.set('author', author)
book.save()

# 获取所有该作者写的书
query = Book.query
query.equal_to('author', author)
book_list = query.find()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
$book = new LeanObject("Book");
$author = User::getCurrentUser();
$book->set("title", "我的第五本书");
$book->set("author", $author);
$book->save();

// 获取所有该作者写的书
$query = new Query("Book");
$query->equalTo("author", $author);
$books = $query->find();
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVObject book = new AVObject("Book");
AVUser author = AVUser.getCurrentUser();
book.put("title", "我的第五本书");
book.put("author", author);
book.saveInBackground().subscribe(new Observer<AVObject>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVObject book) {
        // 获取所有该作者写的书
        AVQuery<AVObject> query = new AVQuery<>("Book");
        query.whereEqualTo("author", author);
        query.findInBackground().subscribe(new Observer<List<AVObject>>() {
            public void onSubscribe(Disposable disposable) {}
            public void onNext(List<AVObject> books) {
                // books 是包含同一作者所有 Book 对象的数组
            }
            public void onError(Throwable throwable) {}
            public void onComplete() {}
        });
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let book = LCObject(className: "Book")
let author = LCApplication.default.currentUser
book.set("title", value: "我的第五本书")
book.set("author", value: author)
_ = book.save { result in
    switch result {
    case .success:
        // 获取所有该作者写的书
        let query = LCQuery(className: "Book")
        query.whereKey("author", .equalTo(author))
        _ = query.find { result in
            switch result {
            case .success(objects: let books):
                // books 是包含同一作者所有 Book 对象的数组
                break
            case .failure(error: let error):
                print(error)
            }
        }
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

### 用户对象的安全

`{{ userObjectName }}` 类自带安全保障，只有通过 `{% if platform_name === "Objective-C" %}logInWithUsername{% endif %}{% if platform_name === "JavaScript" %}logIn{% endif %}{% if platform_name === "Python" %}login{% endif %}{% if platform_name === "PHP" %}logIn{% endif %}{% if platform_name === "Android / Java" %}logIn{% endif %}{% if platform_name === "Swift" %}logIn{% endif %}` 或者 `{% if platform_name === "Objective-C" %}signUpInBackground{% endif %}{% if platform_name === "JavaScript" %}signUp{% endif %}{% if platform_name === "Python" %}sign_up{% endif %}{% if platform_name === "PHP" %}signUp{% endif %}{% if platform_name === "Android / Java" %}signUpInBackground{% endif %}{% if platform_name === "Swift" %}signUp{% endif %}` 这种经过鉴权的方法获取到的 `{{ userObjectName }}` 才能进行保存或删除相关的操作，保证每个用户只能修改自己的数据。

这样设计是因为 `{{ userObjectName }}` 中存储的大多数数据都比较敏感，包括手机号、社交网络账号等等。为了用户的隐私安全，即使是应用的开发者也应避免直接接触这些数据。

下面的代码展现了这种安全措施：

{% if platform_name === "Objective-C" %}
```objc
[AVUser logInWithUsernameInBackground:@"Tom" password:@"cat!@#123" block:^(AVUser *user, NSError *error) {
    if (user != nil) {
        // 试图修改用户名
        [user setObject:@"Jerry" forKey:@"username")];
        // 密码已被加密，这样做会获取到空字符串
        NSString *password = user[@"password"];
        // 保存更改
        [user saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
            if (succeeded) {
                // 可以执行，因为用户已鉴权

                // 绕过鉴权直接获取用户
                AVQuery *query = [AVQuery queryWithClassName:@"_User"]; 
                [query getObjectInBackgroundWithId:user.objectId block:^(AVObject *unauthenticatedUser, NSError *error) {
                    [unauthenticatedUser setObject:@"Toodle" forKey:@"username"];
                    [unauthenticatedUser saveInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
                        if (succeeded) {
                            // 无法执行，因为用户未鉴权
                        } else {
                            // 操作失败
                        }
                    }];
                }];
            } else {
                // 错误处理
            }
        }];
    } else {
        // 错误处理
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var user = AV.User.logIn('Tom', 'cat!@#123').then(function (user) {
  // 试图修改用户名
  user.set('username', 'Jerry');
  // 密码已被加密，这样做会获取到空字符串
  var password = user.get('password');
  // 保存更改
  user.save().then(function (user) {
    // 可以执行，因为用户已鉴权

    // 绕过鉴权直接获取用户
    var query = new AV.Query('_User');
    query.get(user.objectId).then(function (unauthenticatedUser) {
      unauthenticatedUser.set('username', 'Toodle');
      unauthenticatedUser.save().then(function (unauthenticatedUser) { }, function (error) {
        // 会出错，因为用户未鉴权
      });
    });
  });
});
```
{% endif %}
{% if platform_name === "Python" %}
```python
leancloud.User.login('Tom', 'cat!@#123')
current_user = leancloud.User.get_current()

# 试图修改用户名
current_user.set('username', 'Jerry')
# 密码已被加密，这样做会获取到空字符串
password = current_user.get('password')
# 可以执行，因为用户已鉴权
current_user.save()

# 绕过鉴权直接获取用户
query = leancloud.Query('_User')
unauthenticated_user = query.get(current_user.id)
unauthenticated_user.set('username', 'Toodle')
# 会出错，因为用户未鉴权
unauthenticated_user.save()
```
{% endif %}
{% if platform_name === "PHP" %}
```php
User::logIn("Tom", "cat!@#123");
$currentUser = User::getCurrentUser();

// 试图修改用户名
$currentUser->set("username", "Jerry");
// 密码已被加密，这样做会获取到空字符串
$password = $currentUser->get("password");
// 可以执行，因为用户已鉴权
$currentUser->save();

// 绕过鉴权直接获取用户
$query = new Query("_User");
$unauthenticatedUser = $query->get($currentUser->getObjectId())
$unauthenticatedUser->set("username", "Toodle");
// 会出错，因为用户未鉴权
$unauthenticatedUser->save()
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.logIn("Tom", "cat!@#123").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // 试图修改用户名
        user.put("username", "Jerry");
        // 密码已被加密，这样做会获取到空字符串
        String password = user.getString("password");
        // 可以执行，因为用户已鉴权
        user.save();

        // 绕过鉴权直接获取用户
        AVQuery<AVUser> query = new AVQuery<>("_User");
        query.getInBackground(user.getObjectId()).subscribe(new Observer<AVUser>() {
            public void onSubscribe(Disposable disposable) {}
            public void onNext(AVUser unauthenticatedUser) {
                unauthenticatedUser.put("username", "Toodle");
                // 会出错，因为用户未鉴权
                unauthenticatedUser.save();
            }
            public void onError(Throwable throwable) {}
            public void onComplete() {}
        });
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
_ = LCUser.logIn(username: "Tom", password: "cat!@#123") { result in
    switch result {
    case .success(object: let user):
        // 试图修改用户名
        try! user.set("username", "Jerry")
        // 密码已被加密，这样做会获取到空字符串
        let password = user.get("password")
        // 可以执行，因为用户已鉴权
        user.save()

        // 绕过鉴权直接获取用户
        let query = LCQuery(className: "_User")
        _ = query.get(user.objectId) { result in
            switch result {
                case .success(object: let unauthenticatedUser):
                    try! unauthenticatedUser.set("username", "Toodle")
                    _ = unauthenticatedUser.save { result in
                        switch result {
                            .success:
                                // 无法执行，因为用户未鉴权
                            .failure:
                                // 操作失败
                        }
                    }
                case .failure(error: let error):
                    print(error)
            }
        }
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

通过 `{% if platform_name === "Objective-C" %}[AVUser currentUser]{% endif %}{% if platform_name === "JavaScript" %}AV.User.current(){% endif %}{% if platform_name === "Python" %}leancloud.User.get_current(){% endif %}{% if platform_name === "PHP" %}User::getCurrentUser(){% endif %}{% if platform_name === "Android / Java" %}AVUser.getCurrentUser(){% endif %}{% if platform_name === "Swift" %}LCApplication.default.currentUser{% endif %}` 获取的 `{{ userObjectName }}` 总是经过鉴权的。

要查看一个 `{{ userObjectName }}` 是否经过鉴权，可以调用 `{% if platform_name === "Objective-C" %}isAuthenticatedWithSessionToken{% endif %}{% if platform_name === "JavaScript" %}isAuthenticated{% endif %}{% if platform_name === "Python" %}is_authenticated{% endif %}{% if platform_name === "PHP" %}isAuthenticated{% endif %}{% if platform_name === "Android / Java" %}isAuthenticated{% endif %}{% if platform_name === "Swift" %}{# TODO #}{% endif %}` 方法。通过经过鉴权的方法获取到的 `{{ userObjectName }}` 无需进行该检查。

注意，用户的密码只能在注册的时候进行设置，日后如需修改，只能通过 [重置密码](#重置密码) 的方式进行。密码不会被缓存在本地。如果尝试直接获取已登录用户的密码，会得到 `null`。

### 其他对象的安全

对于给定的一个对象，可以指定哪些用户有权限读取或修改它。为实现该功能，每个对象都有一个由 `{% if platform_name === "Objective-C" %}AVACL{% endif %}{% if platform_name === "JavaScript" %}AV.ACL{% endif %}{% if platform_name === "Python" %}leancloud.ACL{% endif %}{% if platform_name === "PHP" %}ACL{% endif %}{% if platform_name === "Android / Java" %}AVACL{% endif %}{% if platform_name === "Swift" %}LCACL{% endif %}` 对象组成的访问控制表。请参阅 [ACL 权限管理开发指南](acl-guide.html)。

{% if node !== "qcloud" %}
### 第三方账户登录

LeanCloud 允许应用将用户账户与微信、QQ 等第三方平台关联起来，这样用户就可以直接用第三方账户登录应用。比如说允许用户使用微信登录，那么你的代码会像这样：

{% if platform_name === "Objective-C" %}
```objc
NSDictionary *authData = @{
                            // 必须
                            @"openid":@"OPENID",
                            @"access_token":@"ACCESS_TOKEN",
                            @"expires_in":@7200,

                            // 可选
                            @"refresh_token":@"REFRESH_TOKEN",
                            @"scope":@"SCOPE",
                            };
AVUser *user = [AVUser user];
AVUserAuthDataLoginOption *option = [AVUserAuthDataLoginOption new];
option.platform = LeanCloudSocialPlatformWeiXin;
[user loginWithAuthData:authData platformId:LeanCloudSocialPlatformWeiXin options:option callback:^(BOOL succeeded, NSError * _Nullable error) {
    if (succeeded) {
            NSLog(@"登录成功");
        }else{
            NSLog(@"登录失败：%@",error.localizedFailureReason);
        }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var authData = {
  // 必须
  openid:        'OPENID',
  access_token:  'ACCESS_TOKEN',
  expires_in:    7200,

  // 可选
  refresh_token: 'REFRESH_TOKEN',
  scope:         'SCOPE'
};
AV.User.loginWithAuthData(authData, 'weixin').then(function (user) {
  // 登录成功
}, function (error) {
  // 登录失败
});
```
{% endif %}
{% if platform_name === "Python" %}
{# TODO #}
{% endif %}
{% if platform_name === "PHP" %}
{# TODO #}
{% endif %}
{% if platform_name === "Android / Java" %}
```java
Map<String, Object> authData = new HashMap<String, Object>();
// 必须
authData.put("expires_in", 7200);
authData.put("openid", "OPENID");
authData.put("access_token", "ACCESS_TOKEN");
//可选
authData.put("refresh_token", "REFRESH_TOKEN");
authData.put("scope", "SCOPE");
AVUser.loginWithAuthData(authData, "weixin").subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser avUser) {
       System.out.println("成功登录");
    }
    public void onError(Throwable throwable) {
       System.out.println("尝试使用第三方账号登录，发生错误。");
    }
    public void onComplete() {}
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let authData: [String: Any] = [
    // 必须
    "openid":        "OPENID",
    "access_token":  "ACCESS_TOKEN",
    "expires_in":    7200,

    // 可选
    "refresh_token": "REFRESH_TOKEN",
    "scope":         "SCOPE"
]
let user = LCUser()
user.logIn(authData: authData, platform: .weixin) { (result) in
    switch result {
    case .success:
        assert(user.objectId != nil)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}

云端会验证传入的 `authData` 是否合法，并且查询是否已经存在与之关联的用户。如果有的话，则返回 `200 OK` 状态码，同时附上用户的信息（包括 [`sessionToken`](#设置当前用户)）。

如果 `authData` 没有和任何用户关联，客户端会收到 `201 Created` 状态码，意味着新用户被创建，同时附上用户的 `objectId`、`createdAt`、`sessionToken` 和一个自动生成的 `username`，例如：

```json
{
  "username":     "k9mjnl7zq9mjbc7expspsxlls",
  "objectId":     "5b029266fb4ffe005d6c7c2e",
  "createdAt":    "2018-05-21T09:33:26.406Z",
  "updatedAt":    "2018-05-21T09:33:26.575Z",
  "sessionToken": "…",
  // authData 通常不会返回
  // 继续阅读以了解其中原因
  "authData": {
    // …
  }
  // …
}
```

出于安全考虑，`authData` 不会被返回给客户端，除非它属于当前用户。

为确保每个 `{{ userObjectName }}` 只会关联每个平台一次，`_User` class 中每个用户的 `authData.<SERVICE_NAME>.openid` 需要保持独一无二。

#### 配置平台账号

开始使用前，需要在 [控制台 > 组件 > 社交](/dashboard/devcomponent.html?appid={{appid}}#/component/sns) 配置相应平台的 **应用 ID** 和 **应用 Secret Key**。点击保存，自动生成 **回调 URL** 和 **登录 URL**。

以微博开放平台举例，它需要单独配置 **回调 URL**。在微博开放平台的 **应用信息** > **高级信息** > **OAuth2.0 授权设置** 里的「授权回调页」中绑定生成的 **回调 URL**。测试阶段，在微博开放平台的 **应用信息** > **测试信息** 添加微博账号，在腾讯开放平台的 **QQ 登录** > **应用调试者** 里添加 QQ 账号即可。在应用通过审核后，可以获取公开的第三方登录能力。

配置平台账号的目的在于创建 `{{ userObjectName }}` 时，LeanCloud 云端会使用相关信息去校验 `authData` 的合法性，确保 `{{ userObjectName }}` 实际对应着一个合法真实的用户，确保平台安全性。如果想关闭自动校验 `authData` 的功能，需要在 [控制台 > 组件 > 社交](/dashboard/devcomponent.html?appid={{appid}}#/component/sns) 中 **取消勾选**「第三方登录时，验证用户 AccessToken 合法性」。

#### 鉴权数据

`authData` 是一个以平台名为键名，鉴权信息为键值的 JSON 对象。你需要自己完成鉴权流程（一般通过 OAuth 1.0 或 2.0）以从平台那边获取鉴权信息。

一个关联了微信账户的用户应该会有下列对象作为 `authData`：

```json
{
  "weixin": {
    "openid":        "…",
    "access_token":  "…",
    "expires_in":    7200,
    "refresh_token": "…",
    "scope":         "…"
  }
}
```

云端会自动验证部分服务的 access token 的有效性以防止伪造请求。如果验证失败，云端会返回 `invalid authData` 错误，关联不会被建立。对于云端无法识别的服务，你需要自己去验证 access token 的有效性。如果不希望云端自动验证 access token，可以在 [控制台 > 存储 > 设置](/dashboard/storage.html?appid={{appid}}#/storage/conf) 里面取消勾选 **第三方登录时，验证用户 AccessToken 合法性**。

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Swift" or platform_name === "Android / Java" %}
#### 扩展需求

##### 新用户登录时必须填用户信息

满足需求：一个新用户使用第三方账号授权拿到相关信息后，仍然需要设置账号相关的用户名、手机号、密码等重要信息后，才被允许登录成功。

这时要使用 `loginWithauthData` 登录接口的 `failOnNotExist` 参数并将其设置为 `ture`。服务端会判断是否已存在能匹配上的 `authData`，否的话，返回 `211` 错误码和 `Could not find user` 报错信息。开发者根据这个 `211` 错误码，跳转到要求输入用户名、密码、手机号等信息的页面，实例化一个 `{{ userObjectName }}` 对象，保存上述补充数据，再次调用 `loginWithauthData` 接口进行登录，并 **不再传入 `failOnNotExist` 参数**。示例代码如下：

{% if platform_name === "Objective-C" %}
```objc
NSDictionary *authData = @{
                            @"access_token":@"ACCESS_TOKEN",
                            @"expires_in":@7200,
                            @"refresh_token":@"REFRESH_TOKEN",
                            @"openid":@"OPENID",
                            @"scope":@"SCOPE",
                            };
AVUser *user = [AVUser user];
AVUserAuthDataLoginOption *option = [AVUserAuthDataLoginOption new];
option.platform = LeanCloudSocialPlatformWeiXin;
option.failOnNotExist = true;
[user loginWithAuthData:authData platformId:LeanCloudSocialPlatformWeiXin options:option callback:^(BOOL succeeded, NSError * _Nullable error) {
    if (succeeded) {
        // 你的逻辑
    } else if ([error.domain isEqualToString:kLeanCloudErrorDomain] && error.code == 211) {
        // 不存在 authData 的 AVUser 的实例，跳转到输入用户名、密码、手机号等业务页面
    }
}];

// 跳转到输入用户名、密码、手机号等业务页面之后
AVUser *user = [AVUser user];
user.username = @"Tom";
user.mobilePhoneNumber = @"+8618200008888";
AVUserAuthDataLoginOption *option = [AVUserAuthDataLoginOption new];
option.platform = LeanCloudSocialPlatformWeiXin;
[user loginWithAuthData:authData platformId:LeanCloudSocialPlatformWeiXin options:option callback:^(BOOL succeeded, NSError * _Nullable error) {
        if (succeeded) {
            NSLog(@"登录成功");
    }else{
            NSLog(@"登录失败：%@",error.localizedFailureReason);
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var authData = {
  access_token: 'ACCESS_TOKEN',
  expires_in: 7200,
  refresh_token: 'REFRESH_TOKEN',
  openid: 'OPENID',
  scope: 'SCOPE',
};
AV.User.loginWithAuthData(authData, 'weixin', { failOnNotExist: true }).then(function (s) {
  // 登录成功
}, function (error) {
  // 登录失败
  // 检查 error.code == 211，跳转到用户名、手机号等资料的输入页面
});

var user = new AV.User();
// 设置用户名
user.setUsername('Tom');
// 设置密码
user.setMobilePhoneNumber('+8618200008888');
user.setPassword('cat!@#123');
// 设置邮箱
user.setEmail('tom@leancloud.rocks');
user.loginWithAuthData(authData, 'weixin').then(function (loggedInUser) {
  console.log(loggedInUser);
}, function (error) {
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let authData: [String: Any] = [
    "access_token": "ACCESS_TOKEN",
    "expires_in": 7200,
    "refresh_token": "REFRESH_TOKEN",
    "openid": "OPENID",
    "scope": "SCOPE"
]
let user = LCUser()
user.logIn(authData: authData, platform: .weixin, options: [.failOnNotExist]) { (result) in
    switch result {
    case .success:
        assert(user.objectId != nil)
    case .failure(error: let error):
        if error.code == 211 {
            // 不存在绑定了当前 authData 的 User 的实例
            // 跳转到输入用户名、密码、手机号等业务页面
            let user = LCUser()
            user.username = "Tom"
            user.password = "cat!@#123"
            user.mobilePhoneNumber = "+8618200008888"
            user.logIn(authData: authData, platform: .weixin, completion: { (result) in
                switch result {
                case .success:
                    assert(user.objectId != nil)
                case .failure(error: let error):
                    print(error)
                }
            })
        }
    }
}
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
Map<String, Object> authData = new HashMap<String, Object>();
authData.put("expires_in", 7200);
authData.put("openid", "OPENID");
authData.put("access_token", "ACCESS_TOKEN");
authData.put("refresh_token", "REFRESH_TOKEN");
authData.put("scope", "SCOPE");
Boolean failOnNotExist = true;
AVUser user = new AVUser();
user.loginWithAuthData(authData,"weixin",failOnNotExist).subscribe(new Observer<AVUser>() {
    @Override
    public void onSubscribe(Disposable d) {
    }
    @Override
    public void onNext(AVUser avUser) {
        System.out.println("存在匹配的用户，登录成功");
    }
    @Override
    public void onError(Throwable e) {
        AVException avException = new AVException(e);
        int code = avException.getCode();
        if (code == 211){
            // 跳转到输入用户名、密码、手机号等业务页面
        } else {
            System.out.println("发生错误:" + e.getMessage());
        }
    }
    @Override
    public void onComplete() {
    }
});

// 跳转到输入用户名、密码、手机号等业务页面之后
AVUser avUser = new AVUser();
avUser.setUsername("Tom");
avUser.setMobilePhoneNumber("+8618200008888");
avUser.loginWithAuthData(authData, "weixin").subscribe(new Observer<AVUser>() {
    @Override
    public void onSubscribe(Disposable d) {
    }
    @Override
    public void onNext(AVUser avUser) {
        System.out.println("登录成功");
    }
    @Override
    public void onError(Throwable e) {
        System.out.println("登录失败：" + e.getMessage());
    }
    @Override
    public void onComplete() {
    }
});
```
{% endif %}

##### 接入 UnionID 体系

随着第三方平台的账户体系变得日渐复杂，它们的 `authData` 出现了一些较大的变化。下面我们以最典型的微信开放平台为例来进行说明。

当一个用户在移动应用内登录微信账号时，会被分配一个 OpenID；在微信小程序内登录账号时，又会被分配另一个不同的 OpenID。这样的架构会导致的问题是，使用同一个微信号的用户，也无法在微信开发平台下的移动应用和小程序之间互通。

微信官方为了解决这个问题，引入 UnionID 的体系，即：**同一微信号，对同一个微信开放平台账号下的不同应用，不管是移动 app、网站应用还是小程序，UnionID 都是相同的。**也就是说，UnionID 可以作为用户的唯一标识。

其他平台，如 QQ 的 UnionID 体系，和微信的设计保持一致。

LeanCloud 支持 UnionID 体系。你只需要给 `loginWithauthData` 和 `associateWithauthData` 接口传入更多的参数，即可完成新 UnionID 体系的集成。

要使用到的关键参数列表：

参数名 | 类型 | 意义
--- | ---- | ---
`platform` | String | 平台，命名随意，如 `weixinapp`、`wxminiprogram`、`qqapp1` 等。
`unionIdPlatform` | String | UnionID 平台，如 `weixin`、`weibo` 和 `qq` 等。
`unionId` | String | 由 UnionID 平台提供。**需配合 `asMainAccount`、`unionIdPlatform` 一起使用**。
`asMainAccount` | boolean | true 代表将 UnionID 绑定入当前 authData 并作为主账号，之后以该 UnionID 来识别。**需配合 `unionId`、`unionIdPlatform` 一起使用**。

接入新 UnionID 系统时，每次传入的 `authData` 必须包含成对的平台 `uid` 或 `openid` 和平台 `unionid`。示例代码如下：

{% if platform_name === "Objective-C" %}
```objc
NSDictionary *authData = @{
                            @"access_token":@"ACCESS_TOKEN",
                            @"expires_in":@7200,
                            @"refresh_token":@"REFRESH_TOKEN",
                            @"openid":@"OPENID",
                            @"scope":@"SCOPE",
                            @"unionid":@"o6_bmasdasdsad6_2sgVt7hMZOPfL"
                            };
AVUser *currentuser = [AVUser user];
AVUserAuthDataLoginOption *option = [AVUserAuthDataLoginOption new];
option.platform = LeanCloudSocialPlatformWeiXin;
option.unionId = authData[@"unionid"];
option.isMainAccount = true;
[currentuser loginWithAuthData:authData platformId:@"weixinapp1" options:option callback:^(BOOL succeeded, NSError * _Nullable error) {
    if (succeeded) {
            NSLog(@"登录成功");
        }else{
            NSLog(@"登录失败：%@",error.localizedFailureReason);
        }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var authData = {
  access_token: 'ACCESS_TOKEN',
  expires_in: 7200,
  refresh_token: 'REFRESH_TOKEN',
  openid: 'OPENID',
  scope: 'SCOPE',
};

AV.User.loginWithAuthDataAndUnionId(
  authData,
  'weixinapp1', 'o6_bmasdasdsad6_2sgVt7hMZOPfL',
  {
    unionIdPlatform: 'weixin',
    asMainAccount: true,
  }
).then(function (user) {
  // 绑定成功
}, function (error) {
  // 绑定失败 
});
```
{% endif %}
{% if platform_name === "Swift" %}
```swift
let authData: [String: Any] = [
    "access_token": "ACCESS_TOKEN",
    "expires_in": 7200,
    "refresh_token": "REFRESH_TOKEN",
    "openid": "OPENID",
    "scope": "SCOPE",
    "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"
]
let user = LCUser()
user.logIn(
    authData: authData,
    platform: .custom("weixinapp1"),
    unionID: authData["unionid"] as? String,
    unionIDPlatform: .weixin,
    options: [.mainAccount])
{ (result) in
    switch result {
    case .success:
        assert(user.objectId != nil)
    case .failure(error: let error):
        print(error)
    }
}
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
Map<String, Object> authData = new HashMap<String, Object>();
authData.put("expires_in", 7200);
authData.put("openid", "OPENID");
authData.put("access_token", "ACCESS_TOKEN");
authData.put("refresh_token", "REFRESH_TOKEN");
authData.put("scope", "SCOPE");
AVUser.loginWithAuthData(authData, "weixinapp1","UnionId","weixin",true).subscribe(new Observer<AVUser>() {
    @Override
    public void onSubscribe(Disposable d) {
    }
    @Override
    public void onNext(AVUser avUser) {
        System.out.println("登录成功");
    }
    @Override
    public void onError(Throwable e) {
        System.out.println("登录失败：" + e.getMessage());
    }
    @Override
    public void onComplete() {
    }
});
```
{% endif %}
然后让我们来看看生成的 `authData` 的数据格式：

```json
{
  "weixinapp1": {
    "platform": "weixin",
    "openid": "oTY851axxxgujsEl0f36Huxk",
    "expires_in": 7200,
    "main_account": true,
    "access_token": "10_chx_dLz402ozf3TX1sTFcQQyfABgilOa-xxx-1HZAaC60LEo010_ab4pswQ",
    "unionid": "ox7NLs06ZGfdxxxxxe0F1po78qE"
  },
  "_weixin_unionid": {
    "uid": "ox7NLs06ZGfdxxxxxe0F1po78qE"
  }
}
```

当你想加入该 UnionID 下的一个新平台，比如 `miniprogram1` 时，再次登录后生成的数据为：

```json
{
  "weixinapp1": {
    "platform": "weixin",
    "openid": "oTY851axxxgujsEl0f36Huxk",
    "expires_in": 7200,
    "main_account": true,
    "access_token": "10_chx_dLz402ozf3TX1sTFcQQyfABgilOa-xxx-1HZAaC60LEo010_ab4pswQ",
    "unionid": "ox7NLs06ZGfdxxxxxe0F1po78qE"
  },
  "_weixin_unionid": {
    "uid": "ox7NLs06ZGfdxxxxxe0F1po78qE"
  },
  "miniprogram1": {
    "platform": "weixin",
    "openid": "ohxoK3ldpsGDGGSaniEEexxx",
    "expires_in": 7200,
    "main_account": true,
    "access_token": "10_QfDeXVp8fUKMBYC_d4PKujpuLo3sBV_pxxxxIZivS77JojQPLrZ7OgP9PC9ZvFCXxIa9G6BcBn45wSBebsv9Pih7Xdr4-hzr5hYpUoSA",
    "unionid": "ox7NLs06ZGfdxxxxxe0F1po78qE"
  }
}
```

可以看到，最终该 `authData` 实际包含了来自 `weixin` 这个 UnionID 体系内的两个不同平台，`weixinapp1` 代表来自移动应用，`miniprogram1` 来自小程序。`_weixin_unionid` 这个字段的值就是用户在 `weixin` 这个 UnionID 平台的唯一标识 UnionID 值。

当一个用户以来自 `weixinapp` 的 OpenID `oTY851axxxgujsEl0f36Huxk` 和 UnionID `ox7NLs06ZGfdxxxxxe0F1po78qE` 一起传入生成新的 `{{ userObjectName }}` 后，接下来这个用户以来自 `miniprogram` 不同的 OpenID `ohxoK3ldpsGDGGSaniEEexxx` 和同样的 UnionID `ox7NLs06ZGfdxxxxxe0F1po78qE` 一起传入时，LeanCloud 判定是同样的 UnionID，就直接把来自 `miniprogram` 的新用户数据加入到已有 `authData` 里了，不会再创建新的用户。

这样一来，LeanCloud 后台通过识别平台性的用户唯一标识 UnionID，让来自同一个 UnionID 体系内的应用程序、小程序等不同平台的用户都绑定到了一个 `{{ userObjectName }}` 上，实现互通。

##### 已有 authData 应用接入 UnionID

先梳理一遍业务，看看是否在过去开发过程集成了移动应用程序、小程序等多个平台的 `authData`，导致同一个用户的数据已经被分别保存为不同的 `{{ userObjectName }}`。

如果没有的话，直接按前面 [接入 UnionID 体系](#接入-unionid-体系) 小节的代码集成即可。

如果有的话，需要确认自身的业务需要，确定要以哪个已有平台的账号为主。比如决定使用某个移动应用上生成的账号，则在该移动应用程序更新版本时，使用 `asMainAccount` 参数。这个移动应用带着 UnionID 登录匹配或创建的账号将作为主账号，之后所有这个 UnionID 的登录都会匹配到这个账号。

请注意，在第二种情况下 `_User` 表里会剩下一些用户数据，也就是没有被选为主账号的、其他平台的同一个用户的旧账号数据。这部分数据会继续服务于已经发布的但仍然使用 OpenID 登录的旧版应用。
{% endif %}

#### 解除关联

可以通过将对应平台的 `authData` 设为 `null` 的方式解除关联。下面的代码解除用户和微信账户的关联：

{% if platform_name === "Objective-C" %}
{# TODO #}
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.loginWithAuthData(null, 'weixin').then(function (s) {
  // 解除关联成功
}, function (error) {
  // 解除关联失败
});
```
{% endif %}
{% if platform_name === "Python" %}
{# TODO #}
{% endif %}
{% if platform_name === "PHP" %}
{# TODO #}
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser avUser = AVUser.currentUser();
avUser.dissociateWithAuthData("weixinapp1").subscribe(new Observer<AVUser>() {
    @Override
    public void onSubscribe(Disposable d) {
    }
    @Override
    public void onNext(AVUser avUser) {
        System.out.println("解绑成功");
    }
    @Override
    public void onError(Throwable e) {
        System.out.println("解绑失败：" + e.getMessage());
    }
    @Override
    public void onComplete() {
    }
});
```
{% endif %}
{% if platform_name === "Swift" %}
{# TODO #}
{% endif %}
{% endif %}

{% if platform_name === "Objective-C" or platform_name === "JavaScript" or platform_name === "Android / Java" %}
### 匿名用户

将数据与用户关联需要首先创建一个用户，但有时你不希望强制用户在一开始就进行注册。使用匿名用户，可以让应用不提供注册步骤也能创建用户。下面的代码创建一个新的匿名用户：

{% if platform_name === "Objective-C" %}
```objc
[AVUser loginAnonymouslyWithCallback:^(AVUser *user, NSError *error) {
    // user 是新的匿名用户
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
AV.User.loginAnonymously().then(function (user) {
  // user 是新的匿名用户
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
AVUser.logInAnonymously().subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // user 是新的匿名用户
    }
    public void onError(Throwable throwable) {}
    public void onComplete() {}
});
```
{% endif %}

可以像给普通用户设置属性那样给匿名用户设置 `username`、`password`、`email` 等属性，还可以通过走正常的注册流程来将匿名用户转化为普通用户。匿名用户能够：

- [使用用户名和密码注册](#注册)
- [关联第三方平台](#第三方账户登录)，比如微信

下面的代码为一名匿名用户设置用户名和密码：

{% if platform_name === "Objective-C" %}
```objc
// currentUser 是个匿名用户
AVUser *currentUser = [AVUser currentUser];

user.username = @"Tom";
user.password = @"cat!@#123";

[user signUpInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {
    if (succeeded) {
        // currentUser 已经转化为普通用户
    } else {
        // 注册失败（通常是因为用户名已被使用）
    }
}];
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
// currentUser 是个匿名用户
var currentUser = AV.User.current();

user.setUsername('Tom');
user.setPassword('cat!@#123');

user.signUp().then(function (user) {
  // currentUser 已经转化为普通用户
}, function (error) {
  // 注册失败（通常是因为用户名已被使用）
});
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
// currentUser 是个匿名用户
AVUser currentUser = AVUser.getCurrentUser();

currentUser.setUsername("Tom");
currentUser.setPassword("cat!@#123");

currentUser.signUpInBackground().subscribe(new Observer<AVUser>() {
    public void onSubscribe(Disposable disposable) {}
    public void onNext(AVUser user) {
        // currentUser 已经转化为普通用户
    }
    public void onError(Throwable throwable) {
        // 注册失败（通常是因为用户名已被使用）
    }
    public void onComplete() {}
});
```
{% endif %}

下面的代码检查当前用户是否为匿名用户：

{% if platform_name === "Objective-C" %}
```objc
AVUser *currentUser = [AVUser currentUser];
if (currentUser.isAnonymous) {
    // currentUser 是匿名用户
} else {
    // currentUser 不是匿名用户
}
```
{% endif %}
{% if platform_name === "JavaScript" %}
```js
var currentUser = AV.User.current();
if (currentUser.isAnonymous()) {
  // currentUser 是匿名用户
} else {
  // currentUser 不是匿名用户
}
```
{% endif %}
{% if platform_name === "Android / Java" %}
```java
{# TODO #}
```
{% endif %}

如果匿名用户未能在登出前转化为普通用户，那么该用户将无法再次登录同一账户，且之前产生的数据也无法被取回。
{% endif %}

## 角色

随着用户量的增长，你可能会发现相比于为每一名用户单独设置权限，将预先设定好的权限直接分配给一部分用户是更好的选择。为了迎合这种需求，LeanCloud 支持基于角色的权限管理。请参阅 [ACL 权限管理开发指南](acl-guide.html)。

{% if platform_name === "Objective-C" or platform_name === "Python" or platform_name === "PHP" or platform_name === "Swift" %}
## 子类化

{% if platform_name === "Objective-C" %}
子类化推荐给进阶的开发者在进行代码重构的时候做参考。你可以用 `AVObject` 访问到所有的数据，用 `objectForKey:` 获取任意字段。在成熟的代码中，子类化有很多优势，包括降低代码量，具有更好的扩展性，和支持自动补全。

子类化是可选的，请对照下面的例子来加深理解：

```
AVObject *student = [AVObject objectWithClassName:@"Student"];
[student setObject:@"小明" forKey:@"name"];
[student saveInBackground];
```

可改写成：

```
Student *student = [Student object];
student.name = @"小明";
[student saveInBackground];
```

这样代码看起来是不是更简洁呢？

### 子类化的实现

要实现子类化，需要下面几个步骤：

1. 导入 `AVObject+Subclass.h`；
2. 继承 `AVObject` 并实现 `AVSubclassing` 协议；
3. 实现类方法 `parseClassName`，返回的字符串是原先要传给 `initWithClassName:` 的参数，这样后续就不必再进行类名引用了。如果不实现，默认返回的是类的名字。**请注意：`AVUser` 子类化后必须返回 `_User`**；
4. 在实例化子类之前调用 `[YourClass registerSubclass]`（**在应用当前生命周期中，只需要调用一次**。可在子类的 `+load` 方法或者 `UIApplication` 的 `-application:didFinishLaunchingWithOptions:` 方法里面调用）。

下面是实现 `Student` 子类化的例子：

```objc
  // Student.h
  #import <AVOSCloud/AVOSCloud.h>

  @interface Student : AVObject <AVSubclassing>

  @property(nonatomic,copy) NSString *name;

  @end


  // Student.m
  #import "Student.h"

  @implementation Student

  @dynamic name;

  + (NSString *)parseClassName {
      return @"Student";
  }

  @end


  // AppDelegate.m
  #import <AVOSCloud/AVOSCloud.h>
  #import "Student.h"

  - (BOOL)application:(UIApplication *)application
  didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    [Student registerSubclass];
    [AVOSCloud setApplicationId:appid clientKey:appkey];
  }
```

### 属性

为 `AVObject` 的子类添加自定义的属性和方法，可以更好地将这个类的逻辑封装起来。用 `AVSubclassing` 可以把所有的相关逻辑放在一起，这样不必再使用不同的类来区分业务逻辑和存储转换逻辑了。

`AVObject` 支持动态 synthesizer，就像 `NSManagedObject` 一样。先正常声明一个属性，只是在 `.m` 文件中把 `@synthesize` 变成 `@dynamic`。

请看下面的例子是怎么添加一个「年龄」属性：

```objc
  // Student.h
  #import <AVOSCloud/AVOSCloud.h>

  @interface Student : AVObject <AVSubclassing>

  @property int age;

  @end


  // Student.m
  #import "Student.h"

  @implementation Student

  @dynamic age;

  …
```

这样就可以通过 `student.age = 19` 这样的方式来读写 `age` 字段了，当然也可以写成：

```objc
[student setAge:19]
```

**注意：属性名称保持首字母小写**（错误：`student.Age`；正确：`student.age`）。

`NSNumber` 类型的属性可用 `NSNumber` 或者是它的原始数据类型（`int`、`long` 等）来实现。例如，`[student objectForKey:@"age"]` 返回的是 `NSNumber` 类型，而实际被设为 `int` 类型。

你可以根据自己的需求来选择使用哪种类型。原始类型更为易用，而 `NSNumber` 支持 `nil` 值，这可以让结果更清晰易懂。

注意：`AVRelation` 同样可以作为子类化的一个属性来使用，比如：

```objc
@interface Student : AVUser <AVSubclassing>
@property(retain) AVRelation *friends;
  …
@end

@implementation Student
@dynamic friends;
  …
```

另外，值为 `Pointer` 的实例可用 `AVObject*` 来表示。例如，如果 `Student` 中 `bestFriend` 代表一个指向另一个 `Student` 的键，由于 `Student` 是一个 `AVObject`，因此在表示这个键的值的时候，可以用一个 `AVObject*` 来代替：

```objc
@interface Student : AVUser <AVSubclassing>
@property(nonatomic, strong) AVObject *bestFriend;
 …
@end

@implementation Student
@dynamic bestFriend;
  …
```

提示：当需要更新的时候，最后都要记得加上 `[student save]` 或者对应的后台存储函数进行更新，才会同步至服务器。

如果要使用更复杂的逻辑而不是简单的属性访问，可以这样实现：

```objc
  @dynamic iconFile;

  - (UIImageView *)iconView {
    UIImageView *view = [[UIImageView alloc] initWithImage:kPlaceholderImage];
    view.image = [UIImage imageNamed:self.iconFile];
    return [view autorelease];
  }

```

### 针对 AVUser 子类化的特别说明

假如现在已经有一个基于 `AVUser` 的子类，如上面提到的 `Student`：

```objc
@interface Student : AVUser<AVSubclassing>
@property (retain) NSString *displayName;
@end


@implementation Student
@dynamic displayName;
+ (NSString *)parseClassName {
    return @"_User";
}
@end
```

登录时需要调用 `Student` 的登录方法才能通过 `currentUser` 得到这个子类：

```objc
[Student logInWithUsernameInBackground:@"USER_NAME" password:@"PASSWORD" block:^(AVUser *user, NSError *error) {
        Student *student = [Student currentUser];
        student.displayName = @"YOUR_DISPLAY_NAME";
    }];
```

同样需要调用 `[Student registerSubclass];`，确保在其它地方得到的对象是 `Student`，而非 `AVUser`。

### 初始化子类

创建一个子类实例，要使用 `object` 类方法。要创建并关联到已有的对象，请使用 `objectWithObjectId:` 类方法。

### 子类查询

使用类方法 `query` 可以得到这个子类的查询对象。

例如，查询年龄小于 21 岁的学生：

```objc
  AVQuery *query = [Student query];
  [query whereKey:@"age" lessThanOrEqualTo:@(21)];
  [query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
    if (!error) {
      Student *stu1 = [objects objectAtIndex:0];
      // …
    }
  }];
```
{% endif %}
{% if platform_name === "Python" %}
LeanCloud 希望设计成能让人尽快上手并使用。你可以通过 `{{baseObjectName}}.get()` 方法访问所有的数据。但是在很多现有成熟的代码中，子类化能带来更多优点，诸如简洁、可扩展性以及 IDE 提供的代码自动完成的支持等等。子类化不是必须的，你可以将下列代码转化：

```python
import leancloud

student = leancloud.Object.extend("Student")()
student.set('name', '小明')
student.save()
```

可改写成：

```python
import leancloud

class Student(leancloud.Object):
    pass

student = Student()
student.set('name', '小明')
student.save()
```

### 子类化 `leancloud.Object`

要实现子类化，需要下面几个步骤：

1. 首先声明一个子类继承自 `leancloud.Object`；
2. 子类化时如果有自定义的构造函数，需要在构造函数中调用父类的构造函数。

下面是实现 `Student` 子类化的例子：

```python
import leancloud

class Student(leancloud.Object):
    pass

student = Student()
student.set('name', 'Tom')
student.save()
```

### 访问器、修改器和方法

添加方法到 `leancloud.Object` 的子类有助于封装类的逻辑。你可以将所有跟子类有关的逻辑放到一个地方，而不是分成多个类来分别处理业务逻辑和存储或转换逻辑。

你可以很容易地为 `leancloud.Object` 子类添加访问器和修改器。像平常那样声明字段的 `getter` 和 `setter` 方法，但是通过 `leancloud.Object` 的 `get` 和 `set` 方法来实现它们。下面是这个例子为 `Student` 类创建了一个 `content` 的字段：

```python
import leancloud

class Student(leancloud.Object):
    @property
    def content(self):
        # 可以使用 property 装饰器，方便获取属性
        return self.get('content')

    @content.setter
    def content(self, value):
        # 同样可以给对象的 content 增加 setter
        return self.set('content', value)
```

现在你就可以使用 `student.content` 方法来访问 `content` 字段，并通过 `student.content = "blah blah blah"` 来修改它，并且可以通过 IDE 或者 linter 在运行前就可以发现类型错误。

如果你不仅需要一个简单的访问器，而是有更复杂的逻辑，你可以在子类化时定义和实现自己的方法。

### 初始化子类

你可以使用自定义的构造函数来创建子类对象。子类必须定义一个公开的默认构造函数，并且不修改任何父类 `leancloud.Object` 中的字段，这个默认构造函数将会被 SDK 使用来创建子类的强类型的对象。

要创建一个到现有对象的引用，可以使用 `leancloud.Object.create_without_data()`：

```python
import leancloud

Student = leancloud.Object.extend('Student')
student = Student.create_without_data('573a8459df0eea005e6b711c')
student.fetch()
```

### 查询子类

你可以通过对象的 `query` 属性获取特定的子类的查询对象。下面的例子就查询了用户发表的所有微博列表：

```python
import leancloud

query = leancloud.Query('Student')
user_name = leancloud.User.get_current().get_username()
query.equal_to('publeancloud.User', user_name)
student_list = query.find()

for student in student_list:
    # 你的逻辑
    pass
```
### User 的子类化

leancloud.User 作为 `leancloud.Object` 的子类，同样允许子类化，你可以定义自己的 User 对象。需要继承 User，并且将子类的 `_class_name` 设为 `'_User'`：

```python
import leancloud

class MyUser(leancloud.User):
    def __init__(self):
        leancloud.User.__init__(self)
        self._class_name = '_User' # 这里要指定 _class_name 为 _User

    def set_nickname(self, name):
        self.set('nick_name', name)

    def get_nickname(self):
        return self.get('nick_name')
```
{% endif %}
{% if platform_name === "PHP" %}
LeanCloud 希望设计成能让人尽快上手并使用。你可以通过 `LeanObject#get` 方法访问所有的数据。但是在很多现有成熟的代码中，子类化能带来更多优点，诸如简洁、可扩展性以及 IDE 提供的代码自动完成的支持等等。子类化不是必须的，你可以将下列代码转化：

```php
$student = new LeanObject("Student");
$student->set("name", "小明");
$student->save();
```

可改写成：

```php
$student = new Student();
$student->set("name", "小明");
$student->save();
```

这样代码看起来是不是更简洁呢？

### 子类化 AVObject

要实现子类化，需要下面几个步骤：

1. 首先声明一个子类继承自 `LeanObject`；
2. 子类中声明静态字段 `protected static $className`，对应云端的数据表名；
3. 建议不要重载构造函数 `__construct()`，如果一定需要构造，请确保其接受 2 个参数 `$className` 和 `$objectId`；
4. 将子类注册到 `LeanObject`，如 `Student::registerClass();`。

下面是实现 `Student` 子类化的例子：

```php
// Student.php
use LeanCloud\LeanObject;

class Student extends LeanObject {
    protected static $className = "Student";
}
Student::registerClass();
```

### 访问器、修改器和方法

添加方法到 `LeanObject` 的子类有助于封装类的逻辑。你可以将所有跟子类有关的逻辑放到一个地方，而不是分成多个类来分别处理商业逻辑和存储/转换逻辑。

你可以很容易地添加访问器和修改器到你的 `LeanObject` 子类。像平常那样声明字段的 `getter` 和 `setter` 方法，但是通过 `LeanObject` 的 `get` 和 `set` 方法来实现它们。下面是这个例子为 `Student` 类创建了一个 `content` 的字段：

```php
// Student.php
use LeanCloud\LeanObject;

class Student extends LeanObject {
    protected static $className = "Student";

    public function setContent($value) {
        $this->set("content", $value);
        return $this; // 方便链式调用
    }

    public function getContent() {
        return $this->get("content");
    }
}
Student::registerClass();
```

现在你就可以使用 `$student->getContent()` 方法来访问 `content` 字段，并通过 `$student->setContent("blah blah blah")` 来修改它。

各种数据类型的访问器和修改器都可以这样被定义，使用各种 `get()` 方法的变种，例如 `getInt()`，`getFile()` 或者 `getMap()`。

如果你不仅需要一个简单的访问器，而是有更复杂的逻辑，你也可以实现自己的方法，例如：

```php
public function takeAccusation() {
  // 处理用户举报，当达到某个条数的时候，自动打上屏蔽标志
  $this->increment("accusation", 1);
  if ($this->getAccusation() > 50) {
    $this->setSpam(true);
  }
}
```

### 初始化子类

你可以使用你自定义的构造函数来创建你的子类对象。`LeanObject` 已定义了默认的构造函数，如果需要重载构造函数，请注意其需要接收 2 个参数：`$className` 和 `$objectId`。这个构造函数将会被 SDK 使用来创建子类的对象。

要创建一个到现有对象的引用，可以使用 `LeanObject::create("Student", "abc123")`：

```php
$student = LeanObject::create("Student", "573a8459df0eea005e6b711c");
```

### 查询子类

你可以通过 `LeanObject#getQuery()` 方法获取特定的子类的查询对象。下面的例子就查询了用户发表的所有微博列表：

```php
$query = $post->getQuery();
$query->equalTo("pubUser", User::getCurrentUser()->getUsername());
$query->find();
```
{% endif %}
{% if platform_name === "Swift" %}
子类化推荐给进阶的开发者在进行代码重构的时候做参考。你可以用 `LCObject` 访问到所有的数据，用 `get` 方法获取任意字段，用 `set` 方法给任意字段赋值；你也可以使用子类化来封装 `get` 以及 `set` 方法，增强编码体验。子类化有很多优势，包括减少代码的编写量，具有更好的扩展性，和支持自动补全等等。

### 子类化的实现

要实现子类化，需要下面两个步骤：

1. 继承 `LCObject`；
2. 重载静态方法 `objectClassName`，返回的字符串是原先要传递给 `LCObject(className:)` 初始化方法的参数。如果不实现，默认返回的是类的名字。**请注意：`LCUser` 子类化后必须返回 `_User`**；
3. 注册子类。一般在 `application(_:didFinishLaunchingWithOptions:)` 方法中调用 `static func register()` 方法。

下面是实现 `Student` 子类化的例子：

```swift
class Student: LCObject {

    @objc dynamic var name: LCString?

    override static func objectClassName() -> String {
        return "Student"
    }
}

func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {

    Student.register()
    
    return true
}
```

### 将 Setter 以及 Getter 方法封装成属性

可以将 `LCObject` 的 Setter 和 Getter 方法封装成属性，需使用 `@objc dynamic var` 来声明一个变量，**且该变量的类型为 [`LCValue`](#数据类型)**。

如下所示，两段代码对 `name` 字段的赋值方式等价。

```swift
// Set name for LCObject
do {
    let student = LCObject(className: "Student")
    try student.set("name", value: "小明")
    assert(student.save().isSuccess)
} catch {
    print(error)
}
```
```swift
// Set name for Student
let student = Student()
student.name = "小明"
assert(student.save().isSuccess)
```
{% endif %}
{% endif %}

## 应用内搜索

应用内搜索是一个针对应用数据进行全局搜索的接口，它基于搜索引擎构建，提供更强大的搜索功能。要深入了解其用法和阅读示例代码，请阅读 [应用内搜索指南](app_search_guide.html)。

{% if node !== "qcloud" %}
## 应用内社交

应用内社交，又称「事件流」，在应用开发中出现的场景非常多，包括用户间关注（好友）、朋友圈（时间线）、状态、互动（点赞）、私信等常用功能，请参考 [应用内社交模块](status_system.html)。
{% endif %}

{% if platform_name === "JavaScript" %}
## Push 通知

通过 JavaScript SDK 也可以向移动设备推送消息。

一个简单例子推送给所有订阅了 `public` 频道的设备：

```js
AV.Push.send({
  channels: [ 'public' ],
  data: {
    alert: 'public message'
  }
});
```

这就向订阅了 `public` 频道的设备发送了一条内容为 `public message` 的消息。

如果希望按照某个 `_Installation` 表的查询条件来推送，例如推送给某个 `installationId` 的 Android 设备，可以传入一个 `AV.Query` 对象作为 `where` 条件：

```js
var query = new AV.Query('_Installation');
query.equalTo('installationId', installationId);
AV.Push.send({
  where: query,
  data: {
    alert: 'Public message'
  }
});
```

`AV.Push` 的更多使用信息参考 API 文档 [AV.Push](https://leancloud.github.io/javascript-sdk/docs/AV.Push.html)。更多推送的查询条件和格式，请查阅 [消息推送指南](push_guide.html)。
{% endif %}

{% if platform_name === "JavaScript" %}
## WebView

JS SDK 支持在各种 WebView 中使用，包括 PhoneGap、Cordova、微信 WebView 等。

### Android WebView

如果是 Android WebView，在 Native 代码创建 WebView 的时候你需要打开几个选项，这些选项生成 WebView 的时候默认并不会被打开，需要配置：

1. 因为我们 JS SDK 目前使用了 `window.localStorage`，所以你需要开启 WebView 的 `localStorage`：

   ```java
   yourWebView.getSettings().setDomStorageEnabled(true);
   ```

2. 如果你希望直接调试手机中的 WebView，也同样需要在生成 WebView 的时候设置远程调试，具体使用方式请参考 [Google 官方文档](https://developer.chrome.com/devtools/docs/remote-debugging)。

   ```java
   if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
     yourWebView.setWebContentsDebuggingEnabled(true);
   }
   ```

   注意：这种调试方式仅支持 Android 4.4 以上版本（含 4.4）。
3. 如果你是通过 WebView 来开发界面，Native 调用本地特性的 Hybrid 方式开发你的 App。比较推荐的开发方式是：通过 Chrome 的开发者工具开发界面部分，当界面部分完成，与 Native 再来做数据连调，这种时候才需要用 Remote debugger 方式在手机上直接调试 WebView。这样做会大大节省你开发调试的时间，不然如果界面都通过 Remote debugger 方式开发，可能效率较低。

4. 为了防止通过 JavaScript 反射调用 Java 代码访问 Android 文件系统的安全漏洞，在 Android 4.2 以后的系统中，WebView 中间只能访问通过 [`@JavascriptInterface`](http://developer.android.com/reference/android/webkit/JavascriptInterface.html) 标记过的方法。如果你的目标用户覆盖 4.2 以上的机型，请注意加上这个标记，以避免出现 `Uncaught TypeError`。
{% endif %}
